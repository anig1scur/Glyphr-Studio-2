{
  "version": 3,
  "sources": ["../../../node_modules/svg-to-bezier/dist/svg-to-bezier/tag-convert-circle-ellipse.js", "../../../node_modules/svg-to-bezier/dist/svg-to-bezier/tag-convert-path-arc.js", "../../../node_modules/svg-to-bezier/dist/svg-to-bezier/tag-convert-path.js", "../../../node_modules/svg-to-bezier/dist/svg-to-bezier/tag-convert-polygon-polyline.js", "../../../node_modules/svg-to-bezier/dist/svg-to-bezier/tag-convert-rect.js", "../../../node_modules/svg-to-bezier/dist/svg-to-bezier/transforms.js", "../../../node_modules/svg-to-bezier/dist/svg-to-bezier/xml-to-json.js", "../../../node_modules/svg-to-bezier/dist/svg-to-bezier/svg-to-bezier.js"],
  "sourcesContent": ["import { roundAndSanitize } from './svg-to-bezier.js';\r\n\r\n/**\r\n * Converts an SVG Circle or Ellipse tags to Bezier Data Format\r\n * @param {object} tagData - Object with tag information\r\n * @returns {Array} - resulting path(s) in Bezier Data Format\r\n */\r\nexport function tagConvertCircleEllipse(tagData) {\r\n\tlet bezierPath = [];\r\n\tlet data = tagData?.attributes || {};\r\n\tlet rx, ry;\r\n\r\n\tlet cx = Number(data.cx) || 0;\r\n\tlet cy = Number(data.cy) || 0;\r\n\r\n\tif (tagData.name === 'circle') {\r\n\t\tdata.r = data.r || 0;\r\n\t\trx = Number(data.r) || 0;\r\n\t\try = rx;\r\n\t} else if (tagData.name === 'ellipse') {\r\n\t\t// Parse data allowing for missing or NaN values\r\n\t\trx = Number(data.rx);\r\n\t\try = Number(data.ry);\r\n\t\t// If one radius is missing, use the other\r\n\t\tif (isNaN(rx) && !isNaN(ry)) rx = ry;\r\n\t\tif (isNaN(ry) && !isNaN(rx)) ry = rx;\r\n\t\t// If a radius is still NaN, set to zero\r\n\t\tif (isNaN(rx)) rx = 0;\r\n\t\tif (isNaN(ry)) ry = 0;\r\n\t}\r\n\r\n\tlet ellipseMaxes = {\r\n\t\txMin: cx - rx,\r\n\t\txMax: cx + rx,\r\n\t\tyMin: cy - ry,\r\n\t\tyMax: cy + ry,\r\n\t};\r\n\r\n\tbezierPath = ovalPathFromMaxes(ellipseMaxes);\r\n\treturn [bezierPath];\r\n}\r\n\r\nfunction ovalPathFromMaxes(maxes) {\r\n\tlet lx = maxes.xMin;\r\n\tlet ty = maxes.yMax;\r\n\tlet rx = maxes.xMax;\r\n\tlet by = maxes.yMin;\r\n\r\n\tlet hw = (rx - lx) / 2;\r\n\tlet hh = (ty - by) / 2;\r\n\tlet hwd = hw * 0.448;\r\n\tlet hhd = hh * 0.448;\r\n\r\n\t/*\r\n\t\tThis is \"Glyphr Studio Notation\" \r\n\t\twith an on-path point surrounded by two control points.\r\n\t\tP = Point\r\n\t\tH1 = Control point 'before' the point\r\n\t\tH2 = Control point 'after' the point\r\n\t*/\r\n\r\n\t// First Point - Top\r\n\tlet Pt = { x: roundAndSanitize(lx + hw), y: roundAndSanitize(ty) };\r\n\tlet H1t = { x: roundAndSanitize(lx + hwd), y: roundAndSanitize(ty) };\r\n\tlet H2t = { x: roundAndSanitize(rx - hwd), y: roundAndSanitize(ty) };\r\n\r\n\t// Second Point - Right\r\n\tlet Pr = { x: roundAndSanitize(rx), y: roundAndSanitize(by + hh) };\r\n\tlet H1r = { x: roundAndSanitize(rx), y: roundAndSanitize(ty - hhd) };\r\n\tlet H2r = { x: roundAndSanitize(rx), y: roundAndSanitize(by + hhd) };\r\n\r\n\t// Third Point - Bottom\r\n\tlet Pb = { x: roundAndSanitize(lx + hw), y: roundAndSanitize(by) };\r\n\tlet H1b = { x: roundAndSanitize(rx - hwd), y: roundAndSanitize(by) };\r\n\tlet H2b = { x: roundAndSanitize(lx + hwd), y: roundAndSanitize(by) };\r\n\r\n\t// Fourth Point - Left\r\n\tlet Pl = { x: roundAndSanitize(lx), y: roundAndSanitize(by + hh) };\r\n\tlet H1l = { x: roundAndSanitize(lx), y: roundAndSanitize(by + hhd) };\r\n\tlet H2l = { x: roundAndSanitize(lx), y: roundAndSanitize(ty - hhd) };\r\n\r\n\tlet paths = [\r\n\t\t[Pt, H2t, H1r, Pr],\r\n\t\t[Pr, H2r, H1b, Pb],\r\n\t\t[Pb, H2b, H1l, Pl],\r\n\t\t[Pl, H2l, H1t, Pt],\r\n\t];\r\n\r\n\treturn paths;\r\n}\r\n", "import { roundAndSanitize } from './svg-to-bezier.js';\r\n\r\n/**\r\n * Converts a curve in Arc notation to Cubic Bezier Curve notation.\r\n * This is recursive, as it may take more than one Bezier curve to describe\r\n * a single Arc.\r\n * \t\tCheck this for more math\r\n * \t\thttp://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n *\r\n * @param {number} startX - starting point X value\r\n * @param {number} startY - starting point Y value\r\n * @param {number} radiusX - arc radius in the X direction\r\n * @param {number} radiusY - arc radius in the Y direction\r\n * @param {number} rotationDegrees - rotation of the ellipse in degrees\r\n * @param {boolean} largeArcFlag - is the ellipse sweep greater than 180 degrees\r\n * @param {boolean} sweepFlag - arc sweep is clockwise\r\n * @param {number} endX - ending point X value\r\n * @param {number} endY - ending point Y value\r\n * @param {object} subPath - for recursion, where it takes multiple Bezier curves\r\n * \t\t\t\t\t\t\t\tto describe a single Arc\r\n */\r\nexport function convertArcToCommandToBezier(\r\n\tstartX,\r\n\tstartY,\r\n\tradiusX,\r\n\tradiusY,\r\n\trotationDegrees,\r\n\tlargeArcFlag,\r\n\tsweepFlag,\r\n\tendX,\r\n\tendY,\r\n\tsubPath\r\n) {\r\n\tlet startPoint = { x: startX, y: startY };\r\n\tlet endPoint = { x: endX, y: endY };\r\n\r\n\t// Short circuit for straight-line edge cases\r\n\tif ((startX === endX && startY === endY) || !radiusX || !radiusY) {\r\n\t\treturn [startPoint.x, startPoint.y, endPoint.x, endPoint.y, endPoint.x, endPoint.y];\r\n\t}\r\n\r\n\tlet rotationRadians = rad(rotationDegrees);\r\n\tlargeArcFlag = !!largeArcFlag;\r\n\tsweepFlag = !!sweepFlag;\r\n\r\n\t// Get the ellipse in centerpoint notation\r\n\tlet center = {};\r\n\tlet angleStart;\r\n\tlet angleEnd;\r\n\r\n\tif (subPath) {\r\n\t\tangleStart = subPath[0];\r\n\t\tangleEnd = subPath[1];\r\n\t\tcenter = {\r\n\t\t\tx: subPath[2],\r\n\t\t\ty: subPath[3],\r\n\t\t};\r\n\t} else {\r\n\t\t// Reverse rotate so we're working with an un-rotated ellipse\r\n\t\tstartPoint = rotate(startPoint, rotationRadians * -1);\r\n\t\tendPoint = rotate(endPoint, rotationRadians * -1);\r\n\r\n\t\t// Ensure the start point + radii can reach the end point\r\n\t\t// Scale the radii if they don't reach\r\n\t\tlet halfWidth = (startPoint.x - endPoint.x) / 2;\r\n\t\tlet halfHeight = (startPoint.y - endPoint.y) / 2;\r\n\t\tlet halfHeightSquared = halfHeight * halfHeight;\r\n\t\tlet halfWidthSquared = halfWidth * halfWidth;\r\n\t\tlet hyp = halfWidthSquared / (radiusX * radiusX) + halfHeightSquared / (radiusY * radiusY);\r\n\r\n\t\tif (hyp > 1) {\r\n\t\t\thyp = Math.sqrt(hyp);\r\n\t\t\tradiusX *= hyp;\r\n\t\t\tradiusY *= hyp;\r\n\t\t}\r\n\r\n\t\t// Convert Endpoint Notation to Centerpoint Notation\r\n\t\tlet radiusXSquared = radiusX * radiusX;\r\n\t\tlet radiusYSquared = radiusY * radiusY;\r\n\t\tlet sign = largeArcFlag === sweepFlag ? -1 : 1;\r\n\t\tsign *= Math.sqrt(\r\n\t\t\tMath.abs(\r\n\t\t\t\t(radiusXSquared * radiusYSquared -\r\n\t\t\t\t\tradiusXSquared * halfHeightSquared -\r\n\t\t\t\t\tradiusYSquared * halfWidthSquared) /\r\n\t\t\t\t\t(radiusXSquared * halfHeightSquared + radiusYSquared * halfWidthSquared)\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t\tcenter.x = (sign * radiusX * halfHeight) / radiusY + (startPoint.x + endPoint.x) / 2;\r\n\t\tcenter.y = (sign * -1 * radiusY * halfWidth) / radiusX + (startPoint.y + endPoint.y) / 2;\r\n\t\tangleStart = Math.asin((startPoint.y - center.y) / radiusY);\r\n\t\tangleEnd = Math.asin((endPoint.y - center.y) / radiusY);\r\n\r\n\t\tangleStart = startPoint.x < center.x ? Math.PI - angleStart : angleStart;\r\n\t\tangleEnd = endPoint.x < center.x ? Math.PI - angleEnd : angleEnd;\r\n\r\n\t\tlet twoPI = Math.PI * 2;\r\n\t\tif (angleStart < 0) angleStart = twoPI + angleStart;\r\n\t\tif (angleEnd < 0) angleEnd = twoPI + angleEnd;\r\n\t\tif (sweepFlag && angleStart > angleEnd) angleStart = angleStart - twoPI;\r\n\t\tif (!sweepFlag && angleEnd > angleStart) angleEnd = angleEnd - twoPI;\r\n\t}\r\n\r\n\t// Check to see if we need to break this path into subpaths\r\n\t// to accurately convert to a bezier\r\n\tlet angleDelta = angleEnd - angleStart;\r\n\tlet result = [];\r\n\tlet threshold = (Math.PI * 120) / 180;\r\n\r\n\tif (Math.abs(angleDelta) > threshold) {\r\n\t\tlet angleEndOld = angleEnd;\r\n\t\tlet endPointXOld = endPoint.x;\r\n\t\tlet endPointYOld = endPoint.y;\r\n\t\tangleEnd = angleStart + threshold * (sweepFlag && angleEnd > angleStart ? 1 : -1);\r\n\t\tendPoint.x = center.x + radiusX * Math.cos(angleEnd);\r\n\t\tendPoint.y = center.y + radiusY * Math.sin(angleEnd);\r\n\t\tresult = convertArcToCommandToBezier(\r\n\t\t\tendPoint.x,\r\n\t\t\tendPoint.y,\r\n\t\t\tradiusX,\r\n\t\t\tradiusY,\r\n\t\t\trotationDegrees,\r\n\t\t\t0,\r\n\t\t\tsweepFlag,\r\n\t\t\tendPointXOld,\r\n\t\t\tendPointYOld,\r\n\t\t\t[angleEnd, angleEndOld, center.x, center.y]\r\n\t\t);\r\n\t}\r\n\r\n\t// Convert the result back to Endpoint Notation\r\n\tlet tempPointOne = {\r\n\t\tx: Math.cos(angleStart),\r\n\t\ty: Math.sin(angleStart),\r\n\t};\r\n\r\n\tlet tempPointTwo = {\r\n\t\tx: Math.cos(angleEnd),\r\n\t\ty: Math.sin(angleEnd),\r\n\t};\r\n\r\n\tangleDelta = angleEnd - angleStart;\r\n\tlet multiplier = (Math.tan(angleDelta / 4) * 4) / 3;\r\n\r\n\t// Compute Bezier Points\r\n\tlet p1 = { x: startPoint.x, y: startPoint.y };\r\n\r\n\tlet p2 = {\r\n\t\tx: startPoint.x + radiusX * multiplier * tempPointOne.y,\r\n\t\ty: startPoint.y - radiusY * multiplier * tempPointOne.x,\r\n\t};\r\n\tp2.x = 2 * p1.x - p2.x;\r\n\tp2.y = 2 * p1.y - p2.y;\r\n\r\n\tlet p3 = {\r\n\t\tx: endPoint.x + radiusX * multiplier * tempPointTwo.y,\r\n\t\ty: endPoint.y - radiusY * multiplier * tempPointTwo.x,\r\n\t};\r\n\r\n\tlet p4 = { x: endPoint.x, y: endPoint.y };\r\n\r\n\tresult = [p2.x, p2.y, p3.x, p3.y, p4.x, p4.y].concat(result);\r\n\r\n\tif (subPath) {\r\n\t\treturn result;\r\n\t} else {\r\n\t\tlet finalResult = [];\r\n\r\n\t\t// Rotate the bezier points back to their original rotated angle\r\n\t\tfor (let i = 0; i < result.length; i++) {\r\n\t\t\tif (i % 2) {\r\n\t\t\t\tfinalResult[i] = rotate({ x: result[i - 1], y: result[i] }, rotationRadians).y;\r\n\t\t\t} else {\r\n\t\t\t\tfinalResult[i] = rotate({ x: result[i], y: result[i + 1] }, rotationRadians).x;\r\n\t\t\t}\r\n\t\t\tfinalResult[i] = roundAndSanitize(finalResult[i]);\r\n\t\t}\r\n\r\n\t\treturn finalResult;\r\n\t}\r\n}\r\n\r\n/*\r\n * Helper Functions\r\n */\r\n\r\n/**\r\n * Converts degrees to radians\r\n * 0rad = 0deg, PIrad = 180deg\r\n * @param {Number} deg - degrees in 360 format\r\n * @returns {Number} - degrees in radians\r\n */\r\nfunction rad(deg) {\r\n\treturn deg * (Math.PI / 180);\r\n}\r\n\r\n/**\r\n * Rotates a point a certain number of degrees around another point\r\n * @param {Object} point - x/y point to rotate\r\n * @param {Number} deltaRad - Angle to rotate in radians\r\n * @param {Object} about - x/y point to rotate around (default is 0,0)\r\n * @returns {Object} - x/y point\r\n */\r\nfunction rotate(point, deltaRad, about) {\r\n\tif (!point) return;\r\n\tif (deltaRad === 0) return point;\r\n\r\n\tabout = about || {};\r\n\tabout.x = about.x || 0;\r\n\tabout.y = about.y || 0;\r\n\r\n\tconst newPoint = { x: 0, y: 0 };\r\n\tnewPoint.x =\r\n\t\tMath.cos(deltaRad) * (point.x - about.x) - Math.sin(deltaRad) * (point.y - about.y) + about.x;\r\n\tnewPoint.y =\r\n\t\tMath.sin(deltaRad) * (point.x - about.x) + Math.cos(deltaRad) * (point.y - about.y) + about.y;\r\n\r\n\treturn newPoint;\r\n}\r\n", "import {\r\n\tchunkAndValidateParameters,\r\n\t// log,\r\n\troundAndSanitize,\r\n\tsanitizeParameterData,\r\n} from './svg-to-bezier.js';\r\nimport { convertArcToCommandToBezier } from './tag-convert-path-arc.js';\r\n\r\n/**\r\n * Converts an SVG Path tag to Bezier Data Format\r\n * @param {object} tagData - Object with tag information\r\n * @returns {Array} - resulting path(s) in Bezier Data Format\r\n */\r\nexport function tagConvertPath(tagData = {}) {\r\n\t// log(`\\ntagConvertPath`);\r\n\tconst dAttribute = tagData.attributes.d || '';\r\n\t// log(`\\t dAttribute: ${dAttribute}`);\r\n\r\n\t// Check for commands\r\n\tif (dAttribute.length === 0 || dAttribute.length === 1) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\t// Take the command string and split into an array containing\r\n\t// command objects, comprised of the command letter and parameters\r\n\tlet commands = chunkCommands(dAttribute);\r\n\t// log('After chunkCommands');\r\n\t// log(commands);\r\n\r\n\t// Convert relative commands: m, l, h, v, c, s, q, t, a, z\r\n\t// to absolute commands: M, L, H, V, C, S, Q, T, A, Z\r\n\t// Converting to Absolute should be done before convertLineTo and convertSmoothBeziers\r\n\t// because they are unable to handle relative commands.\r\n\tcommands = convertToAbsolute(commands);\r\n\t// log('After convertToAbsolute');\r\n\t// log(commands);\r\n\r\n\t// Convert chains of parameters to individual command / parameter pairs\r\n\tcommands = splitChainParameters(commands);\r\n\t// log('After splitChainParameters');\r\n\t// log(commands);\r\n\r\n\t// Convert Horizontal and Vertical LineTo commands to regular LineTo commands\r\n\tcommands = convertLineTo(commands);\r\n\t// log('After convertLineTo');\r\n\t// log(commands); // Convert Smooth Cubic Bézier commands S to regular Cubic Bézier commands C\r\n\r\n\t// Convert Smooth Quadratic Bézier commands T to regular Quadratic Bézier commands Q\r\n\tcommands = convertSmoothBeziers(commands);\r\n\t// log('After convertSmoothBeziers');\r\n\t// log(commands);\r\n\r\n\t// Convert Quadratic Bézier Q commands to Cubic Bézier commands C\r\n\tcommands = convertQuadraticBeziers(commands);\r\n\t// log('After convertQuadraticBeziers');\r\n\t// log(commands);\r\n\r\n\t// Convert Elliptical Arc commands A to Cubic Bézier commands C\r\n\tcommands = convertArcs(commands);\r\n\t// log('After convertArcs');\r\n\t// log(commands);\r\n\r\n\t// Do the final conversion to Bezier Data format\r\n\tconst bezierPaths = convertCommandsToBezierPaths(commands);\r\n\r\n\treturn bezierPaths;\r\n}\r\n\r\nfunction convertCommandsToBezierPaths(commands) {\r\n\tlet bezierPaths = [];\r\n\tlet currentPath = [];\r\n\tlet currentX = 0;\r\n\tlet currentY = 0;\r\n\r\n\t// At this point:\r\n\t// The only commands should be M, C, L, Z\r\n\t// Commands should not be chained\r\n\tcommands.forEach((command) => {\r\n\t\tconst params = command.parameters || [];\r\n\t\tparams.forEach((param, i) => (params[i] = roundAndSanitize(param)));\r\n\r\n\t\tif (command.type === 'M') {\r\n\t\t\tcurrentX = params[0];\r\n\t\t\tcurrentY = params[1];\r\n\t\t}\r\n\t\tif (command.type === 'L') {\r\n\t\t\tcurrentPath.push([\r\n\t\t\t\t{ x: currentX, y: currentY },\r\n\t\t\t\tfalse,\r\n\t\t\t\tfalse,\r\n\t\t\t\t{ x: params[0], y: params[1] },\r\n\t\t\t]);\r\n\t\t\tcurrentX = params[0];\r\n\t\t\tcurrentY = params[1];\r\n\t\t}\r\n\t\tif (command.type === 'C') {\r\n\t\t\tcurrentPath.push([\r\n\t\t\t\t{ x: currentX, y: currentY },\r\n\t\t\t\t{ x: params[0], y: params[1] },\r\n\t\t\t\t{ x: params[2], y: params[3] },\r\n\t\t\t\t{ x: params[4], y: params[5] },\r\n\t\t\t]);\r\n\t\t\tcurrentX = params[4];\r\n\t\t\tcurrentY = params[5];\r\n\t\t}\r\n\t\tif (command.type === 'Z') {\r\n\t\t\tif (currentPath[0] && currentPath[0][0]) {\r\n\t\t\t\tcurrentPath.push([\r\n\t\t\t\t\t{ x: currentX, y: currentY },\r\n\t\t\t\t\tfalse,\r\n\t\t\t\t\tfalse,\r\n\t\t\t\t\t{ x: currentPath[0][0].x, y: currentPath[0][0].y },\r\n\t\t\t\t]);\r\n\t\t\t\tcurrentX = currentPath[0][0].x;\r\n\t\t\t\tcurrentY = currentPath[0][0].y;\r\n\t\t\t}\r\n\t\t\tbezierPaths.push(currentPath);\r\n\t\t\tcurrentPath = [];\r\n\t\t}\r\n\t});\r\n\r\n\t// No z command, but end of data\r\n\tif (currentPath.length) bezierPaths.push(currentPath);\r\n\r\n\treturn bezierPaths;\r\n}\r\n\r\n/*\r\n * Prepare + Simplify commands\r\n */\r\n\r\nfunction chunkCommands(dAttribute) {\r\n\t// log(`Start chunkCommands`);\r\n\tlet result = [];\r\n\tlet commandStart = false;\r\n\r\n\tlet data = sanitizeParameterData(dAttribute);\r\n\t// log(data);\r\n\r\n\t// Find the first valid command\r\n\tfor (let j = 0; j < data.length; j++) {\r\n\t\tif (isCommand(data.charAt(j))) {\r\n\t\t\tcommandStart = j;\r\n\t\t\t// log(`First valid command ${data.charAt(j)} found at ${j}`);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (commandStart === false) {\r\n\t\t// No valid commands found\r\n\t\t// log(`No valid commands found, returning Z`);\r\n\t\treturn [{ type: 'Z' }];\r\n\t}\r\n\r\n\t// Loop through the string\r\n\tfor (let i = commandStart + 1; i < data.length; i++) {\r\n\t\tif (isCommand(data.charAt(i))) {\r\n\t\t\tresult.push({\r\n\t\t\t\ttype: data.charAt(commandStart),\r\n\t\t\t\tparameters: chunkAndValidateParameters(data.substring(commandStart + 1, i)),\r\n\t\t\t});\r\n\r\n\t\t\tcommandStart = i;\r\n\t\t}\r\n\t}\r\n\r\n\t// Fencepost\r\n\tif (commandStart < data.length) {\r\n\t\tresult.push({\r\n\t\t\ttype: data.charAt(commandStart),\r\n\t\t\tparameters: chunkAndValidateParameters(data.substring(commandStart + 1, data.length)),\r\n\t\t});\r\n\t}\r\n\r\n\t// log(JSON.stringify(result, null, 2));\r\n\t// log(`End chunkCommands`);\r\n\treturn result;\r\n}\r\n\r\nfunction convertToAbsolute(commands) {\r\n\t// log(`Start convertToAbsolute: ${commands.length} command chunks`);\r\n\tlet result = [];\r\n\tlet newCommand = {};\r\n\tlet currentPoint = { x: 0, y: 0 };\r\n\tlet newPoint = { x: 0, y: 0 };\r\n\tfirstPoint = {};\r\n\r\n\tcommands.forEach((command) => {\r\n\t\t// log(`Command: ${command.type}`);\r\n\t\tif (command.type === 'm' || command.type === 'l') {\r\n\t\t\t// MoveTo and LineTo\r\n\t\t\t// log(`currentPoint: ${currentPoint.x}, ${currentPoint.y}`);\r\n\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: command.type === 'm' ? 'M' : 'L',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i += 2) {\r\n\t\t\t\tnewPoint.x = command.parameters[i + 0] + currentPoint.x;\r\n\t\t\t\tnewPoint.y = command.parameters[i + 1] + currentPoint.y;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(newPoint.y);\r\n\t\t\t\tcurrentPoint.x = newPoint.x;\r\n\t\t\t\tcurrentPoint.y = newPoint.y;\r\n\t\t\t\tif (command.type === 'm') {\r\n\t\t\t\t\t// if a chained m command, firstPoint is the first entry\r\n\t\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 'h') {\r\n\t\t\t// Horizontal line to\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: 'H',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i++) {\r\n\t\t\t\tnewPoint.x = command.parameters[i] + currentPoint.x;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.x);\r\n\t\t\t\tcurrentPoint.x = newPoint.x;\r\n\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 'v') {\r\n\t\t\t// Horizontal line to\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: 'V',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i++) {\r\n\t\t\t\tnewPoint.y = command.parameters[i] + currentPoint.y;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.y);\r\n\t\t\t\tcurrentPoint.y = newPoint.y;\r\n\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 'c') {\r\n\t\t\t// Cubic Bezier\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: 'C',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i += 6) {\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 0] + currentPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 1] + currentPoint.y);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 2] + currentPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 3] + currentPoint.y);\r\n\t\t\t\tnewPoint.x = command.parameters[i + 4] + currentPoint.x;\r\n\t\t\t\tnewPoint.y = command.parameters[i + 5] + currentPoint.y;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(newPoint.y);\r\n\t\t\t\tcurrentPoint.x = newPoint.x;\r\n\t\t\t\tcurrentPoint.y = newPoint.y;\r\n\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 's') {\r\n\t\t\t// Smooth Cubic Bezier\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: 'S',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i += 4) {\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 0] + currentPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 1] + currentPoint.y);\r\n\t\t\t\tnewPoint.x = command.parameters[i + 2] + currentPoint.x;\r\n\t\t\t\tnewPoint.y = command.parameters[i + 3] + currentPoint.y;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(newPoint.y);\r\n\t\t\t\tcurrentPoint.x = newPoint.x;\r\n\t\t\t\tcurrentPoint.y = newPoint.y;\r\n\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 'q') {\r\n\t\t\t// Quadratic Bezier\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: 'Q',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i += 4) {\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 0] + currentPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 1] + currentPoint.y);\r\n\t\t\t\tnewPoint.x = command.parameters[i + 2] + currentPoint.x;\r\n\t\t\t\tnewPoint.y = command.parameters[i + 3] + currentPoint.y;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(newPoint.y);\r\n\t\t\t\tcurrentPoint.x = newPoint.x;\r\n\t\t\t\tcurrentPoint.y = newPoint.y;\r\n\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 't') {\r\n\t\t\t// Smooth Quadratic Bezier\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: 'T',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i += 2) {\r\n\t\t\t\tnewPoint.x = command.parameters[i + 0] + currentPoint.x;\r\n\t\t\t\tnewPoint.y = command.parameters[i + 1] + currentPoint.y;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(newPoint.y);\r\n\t\t\t\tcurrentPoint.x = newPoint.x;\r\n\t\t\t\tcurrentPoint.y = newPoint.y;\r\n\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 'a') {\r\n\t\t\t// Arc to\r\n\t\t\tnewCommand = {\r\n\t\t\t\ttype: 'A',\r\n\t\t\t\tparameters: [],\r\n\t\t\t};\r\n\t\t\t// log(`Arc to relative parameters\\n${command.parameters}`);\r\n\t\t\tfor (let i = 0; i < command.parameters.length; i += 7) {\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 0]);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 1]);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 2]);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 3]);\r\n\t\t\t\tnewCommand.parameters.push(command.parameters[i + 4]);\r\n\t\t\t\tnewPoint.x = command.parameters[i + 5] + currentPoint.x;\r\n\t\t\t\tnewPoint.y = command.parameters[i + 6] + currentPoint.y;\r\n\t\t\t\tnewCommand.parameters.push(newPoint.x);\r\n\t\t\t\tnewCommand.parameters.push(newPoint.y);\r\n\t\t\t\tcurrentPoint.x = newPoint.x;\r\n\t\t\t\tcurrentPoint.y = newPoint.y;\r\n\t\t\t\tsetFirstPoint(newPoint);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(newCommand);\r\n\t\t} else if (command.type === 'z' || command.type === 'Z') {\r\n\t\t\t// End path\r\n\t\t\tcurrentPoint = { x: firstPoint.x, y: firstPoint.y };\r\n\t\t\t// log(`END OF PATH Z: Setting current point to first point`);\r\n\t\t\t// log(`firstPoint: ${firstPoint.x}, ${firstPoint.y}`);\r\n\t\t\t// log(`currentPoint: ${currentPoint.x}, ${currentPoint.y}`);\r\n\t\t\tfirstPoint = false;\r\n\t\t\tresult.push({ type: 'Z' });\r\n\t\t} else {\r\n\t\t\t// command is absolute, push it after updating currentPoint\r\n\t\t\tif (command.type === 'M') {\r\n\t\t\t\t// If a chained M command, firstPoint is the first entry\r\n\t\t\t\tcurrentPoint.x = command.parameters[0];\r\n\t\t\t\tcurrentPoint.y = command.parameters[1];\r\n\t\t\t}\r\n\t\t\tresult.push(command);\r\n\t\t\tsetFirstPoint(currentPoint);\r\n\t\t\tcurrentPoint = getNewEndPoint(currentPoint, command);\r\n\t\t}\r\n\t});\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction splitChainParameters(commands) {\r\n\tlet result = [];\r\n\r\n\tcommands.forEach((command) => {\r\n\t\tif (command.type) {\r\n\t\t\tswitch (command.type) {\r\n\t\t\t\tcase 'Z':\r\n\t\t\t\tcase 'z':\r\n\t\t\t\t\tresult.push({ type: 'Z' });\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'H':\r\n\t\t\t\tcase 'V':\r\n\t\t\t\tcase 'h':\r\n\t\t\t\tcase 'v':\r\n\t\t\t\t\tfor (let p = 0; p < command.parameters.length; p++) {\r\n\t\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\t\ttype: command.type,\r\n\t\t\t\t\t\t\tparameters: [command.parameters[p]],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'M':\r\n\t\t\t\t\t// Chained MoveTo commands are treated like LineTo commands\r\n\t\t\t\t\tfor (let p = 0; p < command.parameters.length; p += 2) {\r\n\t\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\t\ttype: p < 2 ? 'M' : 'L',\r\n\t\t\t\t\t\t\tparameters: [command.parameters[p], command.parameters[p + 1]],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm':\r\n\t\t\t\t\t// Chained MoveTo commands are treated like LineTo commands\r\n\t\t\t\t\tfor (let p = 0; p < command.parameters.length; p += 2) {\r\n\t\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\t\ttype: p < 2 ? 'm' : 'l',\r\n\t\t\t\t\t\t\tparameters: [command.parameters[p], command.parameters[p + 1]],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'L':\r\n\t\t\t\tcase 'T':\r\n\t\t\t\tcase 'l':\r\n\t\t\t\tcase 't':\r\n\t\t\t\t\tfor (let p = 0; p < command.parameters.length; p += 2) {\r\n\t\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\t\ttype: command.type,\r\n\t\t\t\t\t\t\tparameters: [command.parameters[p], command.parameters[p + 1]],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Q':\r\n\t\t\t\tcase 'S':\r\n\t\t\t\tcase 'q':\r\n\t\t\t\tcase 's':\r\n\t\t\t\t\tfor (let p = 0; p < command.parameters.length; p += 4) {\r\n\t\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\t\ttype: command.type,\r\n\t\t\t\t\t\t\tparameters: [\r\n\t\t\t\t\t\t\t\tcommand.parameters[p],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 1],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 2],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 3],\r\n\t\t\t\t\t\t\t],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'C':\r\n\t\t\t\tcase 'c':\r\n\t\t\t\t\tfor (let p = 0; p < command.parameters.length; p += 6) {\r\n\t\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\t\ttype: command.type,\r\n\t\t\t\t\t\t\tparameters: [\r\n\t\t\t\t\t\t\t\tcommand.parameters[p],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 1],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 2],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 3],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 4],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 5],\r\n\t\t\t\t\t\t\t],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'A':\r\n\t\t\t\tcase 'a':\r\n\t\t\t\t\tfor (let p = 0; p < command.parameters.length; p += 7) {\r\n\t\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\t\ttype: command.type,\r\n\t\t\t\t\t\t\tparameters: [\r\n\t\t\t\t\t\t\t\tcommand.parameters[p],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 1],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 2],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 3],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 4],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 5],\r\n\t\t\t\t\t\t\t\tcommand.parameters[p + 6],\r\n\t\t\t\t\t\t\t],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction convertLineTo(commands) {\r\n\t// log(`Start convertLineTo`);\r\n\tlet result = [];\r\n\tlet currentPoint = { x: 0, y: 0 };\r\n\r\n\tcommands.forEach((command) => {\r\n\t\t// log(`doing ${command.type} [${command.parameters.join()}]`);\r\n\r\n\t\tif (command.type === 'H') {\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p++) {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\ttype: 'L',\r\n\t\t\t\t\tparameters: [command.parameters[p], currentPoint.y],\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (command.type === 'V') {\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p++) {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\ttype: 'L',\r\n\t\t\t\t\tparameters: [currentPoint.x, command.parameters[p]],\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tresult.push(command);\r\n\t\t}\r\n\r\n\t\t// log(`pushed ${result.at(-1).type} [${result.at(-1).parameters.join()}]`);\r\n\t\tcurrentPoint = getNewEndPoint(currentPoint, command);\r\n\t\t// log(`new end point ${currentPoint.x}, ${currentPoint.y}`);\r\n\t});\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction convertSmoothBeziers(commands) {\r\n\t// log(`Start convertSmoothBeziers`);\r\n\tlet result = [];\r\n\tlet currentPoint = { x: 0, y: 0 };\r\n\tlet previousHandle = { x: 0, y: 0 };\r\n\tlet smoothHandle = { x: 0, y: 0 };\r\n\tlet previousResult;\r\n\r\n\tcommands.forEach((command) => {\r\n\t\tif (command.type === 'S' || command.type === 'T') {\r\n\t\t\tpreviousResult = result.length > 1 ? result.at(-1) : false;\r\n\r\n\t\t\t// This allows for using a smooth cubic after a quadratic,\r\n\t\t\t// or a smooth quadratic after a cubic... which may not be standard\r\n\t\t\tif (previousResult && previousResult.type === 'C') {\r\n\t\t\t\tpreviousHandle.x = previousResult.parameters[2];\r\n\t\t\t\tpreviousHandle.y = previousResult.parameters[3];\r\n\t\t\t} else if (previousResult && previousResult.type === 'Q') {\r\n\t\t\t\tpreviousHandle.x = previousResult.parameters[0];\r\n\t\t\t\tpreviousHandle.y = previousResult.parameters[1];\r\n\t\t\t} else {\r\n\t\t\t\tpreviousHandle.x = currentPoint.x;\r\n\t\t\t\tpreviousHandle.y = currentPoint.y;\r\n\t\t\t}\r\n\r\n\t\t\tsmoothHandle = {\r\n\t\t\t\tx: currentPoint.x - previousHandle.x + currentPoint.x,\r\n\t\t\t\ty: currentPoint.y - previousHandle.y + currentPoint.y,\r\n\t\t\t};\r\n\r\n\t\t\tif (command.type === 'S') {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\ttype: 'C',\r\n\t\t\t\t\tparameters: [\r\n\t\t\t\t\t\tsmoothHandle.x,\r\n\t\t\t\t\t\tsmoothHandle.y,\r\n\t\t\t\t\t\tcommand.parameters[0],\r\n\t\t\t\t\t\tcommand.parameters[1],\r\n\t\t\t\t\t\tcommand.parameters[2],\r\n\t\t\t\t\t\tcommand.parameters[3],\r\n\t\t\t\t\t],\r\n\t\t\t\t});\r\n\t\t\t} else if (command.type === 'T') {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\ttype: 'Q',\r\n\t\t\t\t\tparameters: [\r\n\t\t\t\t\t\tsmoothHandle.x,\r\n\t\t\t\t\t\tsmoothHandle.y,\r\n\t\t\t\t\t\tcommand.parameters[0],\r\n\t\t\t\t\t\tcommand.parameters[1],\r\n\t\t\t\t\t],\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tresult.push(command);\r\n\t\t}\r\n\r\n\t\tcurrentPoint = getNewEndPoint(currentPoint, command);\r\n\t});\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction convertQuadraticBeziers(commands) {\r\n\tlet result = [];\r\n\tlet currentPoint = { x: 0, y: 0 };\r\n\tlet q0x;\r\n\tlet q0y;\r\n\tlet q1x;\r\n\tlet q1y;\r\n\tlet q2x;\r\n\tlet q2y;\r\n\tlet c1x;\r\n\tlet c1y;\r\n\tlet c2x;\r\n\tlet c2y;\r\n\r\n\tcommands.forEach((command) => {\r\n\t\tif (command.type === 'Q') {\r\n\t\t\tq0x = currentPoint.x;\r\n\t\t\tq0y = currentPoint.y;\r\n\t\t\tq1x = command.parameters[0];\r\n\t\t\tq1y = command.parameters[1];\r\n\t\t\tq2x = command.parameters[2];\r\n\t\t\tq2y = command.parameters[3];\r\n\r\n\t\t\tc1x = q0x + (2 / 3) * (q1x - q0x);\r\n\t\t\tc1y = q0y + (2 / 3) * (q1y - q0y);\r\n\r\n\t\t\tc2x = q2x + (2 / 3) * (q1x - q2x);\r\n\t\t\tc2y = q2y + (2 / 3) * (q1y - q2y);\r\n\r\n\t\t\tresult.push({ type: 'C', parameters: [c1x, c1y, c2x, c2y, q2x, q2y] });\r\n\t\t} else {\r\n\t\t\tresult.push(command);\r\n\t\t}\r\n\r\n\t\tcurrentPoint = getNewEndPoint(currentPoint, command);\r\n\t});\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction convertArcs(commands) {\r\n\tlet result = [];\r\n\tlet convertedBeziers = [];\r\n\tlet currentPoint = { x: 0, y: 0 };\r\n\r\n\tcommands.forEach((command) => {\r\n\t\tif (command.type === 'A') {\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p += 7) {\r\n\t\t\t\tconvertedBeziers = convertArcToCommandToBezier(\r\n\t\t\t\t\tcurrentPoint.x,\r\n\t\t\t\t\tcurrentPoint.y,\r\n\t\t\t\t\tcommand.parameters[p + 0],\r\n\t\t\t\t\tcommand.parameters[p + 1],\r\n\t\t\t\t\tcommand.parameters[p + 2],\r\n\t\t\t\t\tcommand.parameters[p + 3],\r\n\t\t\t\t\tcommand.parameters[p + 4],\r\n\t\t\t\t\tcommand.parameters[p + 5],\r\n\t\t\t\t\tcommand.parameters[p + 6],\r\n\t\t\t\t\tfalse\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// log(`Converted Beziers\\n${convertedBeziers}`);\r\n\r\n\t\t\t\t// Split Chains\r\n\t\t\t\tfor (let i = 0; i < convertedBeziers.length; i += 6) {\r\n\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\ttype: 'C',\r\n\t\t\t\t\t\tparameters: [\r\n\t\t\t\t\t\t\tconvertedBeziers[i + 0],\r\n\t\t\t\t\t\t\tconvertedBeziers[i + 1],\r\n\t\t\t\t\t\t\tconvertedBeziers[i + 2],\r\n\t\t\t\t\t\t\tconvertedBeziers[i + 3],\r\n\t\t\t\t\t\t\tconvertedBeziers[i + 4],\r\n\t\t\t\t\t\t\tconvertedBeziers[i + 5],\r\n\t\t\t\t\t\t],\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentPoint = {\r\n\t\t\t\t\tx: convertedBeziers.at(-2),\r\n\t\t\t\t\ty: convertedBeziers.at(-1),\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tresult.push(command);\r\n\t\t\tcurrentPoint = getNewEndPoint(currentPoint, command);\r\n\t\t}\r\n\t});\r\n\r\n\treturn result;\r\n}\r\n\r\n/*\r\n * Helper Functions\r\n */\r\nlet firstPoint = {};\r\nfunction setFirstPoint(point) {\r\n\tif (!firstPoint.hasOwnProperty('x') && !firstPoint.hasOwnProperty('y')) {\r\n\t\t// log(`Setting First Point! ${point.x}, ${point.y}`);\r\n\t\tfirstPoint = {\r\n\t\t\tx: point.x,\r\n\t\t\ty: point.y,\r\n\t\t};\r\n\t}\r\n}\r\n\r\nfunction getNewEndPoint(currentPoint, command) {\r\n\tlet returnPoint = {\r\n\t\tx: currentPoint.x || 0,\r\n\t\ty: currentPoint.y || 0,\r\n\t};\r\n\r\n\tswitch (command.type) {\r\n\t\tcase 'Z':\r\n\t\tcase 'z':\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'H':\r\n\t\t\treturnPoint.x = command.parameters.at(-1);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'V':\r\n\t\t\treturnPoint.y = command.parameters.at(-1);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'M':\r\n\t\tcase 'L':\r\n\t\tcase 'C':\r\n\t\tcase 'S':\r\n\t\tcase 'A':\r\n\t\tcase 'Q':\r\n\t\tcase 'T':\r\n\t\t\treturnPoint.x = command.parameters.at(-2);\r\n\t\t\treturnPoint.y = command.parameters.at(-1);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'h':\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p++) {\r\n\t\t\t\treturnPoint.x += command.parameters[p];\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'v':\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p++) {\r\n\t\t\t\treturnPoint.y += command.parameters[p];\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'm':\r\n\t\tcase 'l':\r\n\t\tcase 't':\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p += 2) {\r\n\t\t\t\treturnPoint.x += command.parameters[p + 0];\r\n\t\t\t\treturnPoint.y += command.parameters[p + 1];\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'q':\r\n\t\tcase 's':\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p += 4) {\r\n\t\t\t\treturnPoint.x += command.parameters[p + 2];\r\n\t\t\t\treturnPoint.y += command.parameters[p + 3];\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'c':\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p += 6) {\r\n\t\t\t\treturnPoint.x += command.parameters[p + 4];\r\n\t\t\t\treturnPoint.y += command.parameters[p + 5];\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'a':\r\n\t\t\tfor (let p = 0; p < command.parameters.length; p += 7) {\r\n\t\t\t\treturnPoint.x += command.parameters[p + 5];\r\n\t\t\t\treturnPoint.y += command.parameters[p + 6];\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn returnPoint;\r\n}\r\n\r\nfunction isCommand(c) {\r\n\t// log(`isCommand passed ${c}`);\r\n\tif ('MmLlCcSsZzHhVvAaQqTt'.indexOf(c) > -1) return true;\r\n\treturn false;\r\n}\r\n", "import {\r\n\tchunkAndValidateParameters,\r\n\t// log,\r\n\troundAndSanitize,\r\n\tsanitizeParameterData,\r\n} from './svg-to-bezier.js';\r\n\r\n/**\r\n * Converts an SVG Polygon or Polyline tag to Bezier Data Format\r\n * @param {object} tagData - Object with tag information\r\n * @returns {Array} - resulting path(s) in Bezier Data Format\r\n */\r\nexport function tagConvertPolygonPolyline(tagData) {\r\n\t// log(`\\ntagConvertPolygonPolyline`);\r\n\t// log('tagData');\r\n\t// log(tagData);\r\n\r\n\tlet bezierPath = [];\r\n\tlet initialData = tagData?.attributes?.points;\r\n\tinitialData = sanitizeParameterData(initialData);\r\n\tlet data = chunkAndValidateParameters(initialData);\r\n\r\n\t// log('Polyline or Polygon data, cleaned & formatted:');\r\n\t// log(data);\r\n\r\n\tlet firstX = Number(data[0]) || 0;\r\n\tlet firstY = Number(data[1]) || 0;\r\n\tlet previousX = Number(data[0]) || 0;\r\n\tlet previousY = Number(data[1]) || 0;\r\n\r\n\tif (data.length > 4) {\r\n\t\tfor (let i = 0; i < data.length; i += 2) {\r\n\t\t\tlet px = Number(data[i]) || 0;\r\n\t\t\tlet py = Number(data[i + 1]) || 0;\r\n\t\t\tbezierPath.push([\r\n\t\t\t\t{ x: roundAndSanitize(previousX), y: roundAndSanitize(previousY) },\r\n\t\t\t\tfalse,\r\n\t\t\t\tfalse,\r\n\t\t\t\t{ x: roundAndSanitize(px), y: roundAndSanitize(py) },\r\n\t\t\t]);\r\n\t\t\tpreviousX = px;\r\n\t\t\tpreviousY = py;\r\n\t\t}\r\n\t}\r\n\r\n\tif (tagData.name === 'polygon' && data.length > 2) {\r\n\t\t// Polygons are closed by default, Polylines are not\r\n\t\tbezierPath.push([\r\n\t\t\t{ x: roundAndSanitize(previousX), y: roundAndSanitize(previousY) },\r\n\t\t\tfalse,\r\n\t\t\tfalse,\r\n\t\t\t{ x: roundAndSanitize(firstX), y: roundAndSanitize(firstY) },\r\n\t\t]);\r\n\t}\r\n\r\n\treturn [bezierPath];\r\n}\r\n", "import { roundAndSanitize } from './svg-to-bezier.js';\r\n\r\n/**\r\n * Converts an SVG Rect tag to Bezier Data Format\r\n * @param {object} tagData - Object with tag information\r\n * @returns {Array} - resulting path(s) in Bezier Data Format\r\n */\r\nexport function tagConvertRect(tagData) {\r\n\tlet data = tagData.attributes || {};\r\n\tlet x = roundAndSanitize(data.x) || 0;\r\n\tlet y = roundAndSanitize(data.y) || 0;\r\n\tlet w = roundAndSanitize(data.width) || 0;\r\n\tlet h = roundAndSanitize(data.height) || 0;\r\n\tlet right = x + w;\r\n\tlet bottom = y + h;\r\n\tlet upperLeft = { x: x, y: y };\r\n\tlet upperRight = { x: right, y: y };\r\n\tlet lowerRight = { x: right, y: bottom };\r\n\tlet lowerLeft = { x: x, y: bottom };\r\n\tlet bezierPath = [];\r\n\r\n\t// Handle radius corners\r\n\tif (data.rx || data.ry) {\r\n\t\t// Parse data allowing for missing or NaN values\r\n\t\tlet rx = Number(data.rx);\r\n\t\tlet ry = Number(data.ry);\r\n\t\t// If one radius is missing, use the other\r\n\t\tif (isNaN(rx) && !isNaN(ry)) rx = ry;\r\n\t\tif (isNaN(ry) && !isNaN(rx)) ry = rx;\r\n\t\t// If a radius is still NaN, set to zero\r\n\t\tif (isNaN(rx)) rx = 0;\r\n\t\tif (isNaN(ry)) ry = 0;\r\n\t\t// Ensure radii do not exceed half width/height\r\n\t\tif (rx > w / 2) rx = w / 2;\r\n\t\tif (ry > h / 2) ry = h / 2;\r\n\r\n\t\t// do rounded corners\r\n\t\tlet handleWidth = rx * 0.448;\r\n\t\tlet handleHeight = ry * 0.448;\r\n\r\n\t\t// Calculate curve start positions\r\n\t\tlet leftXCurveStart = roundAndSanitize(x + rx);\r\n\t\tlet rightXCurveStart = roundAndSanitize(right - rx);\r\n\t\tlet topYCurveStart = roundAndSanitize(y + ry);\r\n\t\tlet bottomYCurveStart = roundAndSanitize(bottom - ry);\r\n\r\n\t\t// Calculate handle positions\r\n\t\tlet leftXHandle = roundAndSanitize(x + handleWidth);\r\n\t\tlet rightXHandle = roundAndSanitize(right - handleWidth);\r\n\t\tlet topYHandle = roundAndSanitize(y + handleHeight);\r\n\t\tlet bottomYHandle = roundAndSanitize(bottom - handleHeight);\r\n\r\n\t\tbezierPath = [\r\n\t\t\t[{ x: leftXCurveStart, y: y }, false, false, { x: rightXCurveStart, y: y }],\r\n\t\t\t[\r\n\t\t\t\t{ x: rightXCurveStart, y: y },\r\n\t\t\t\t{ x: rightXHandle, y: y },\r\n\t\t\t\t{ x: right, y: topYHandle },\r\n\t\t\t\t{ x: right, y: topYCurveStart },\r\n\t\t\t],\r\n\t\t\t[{ x: right, y: topYCurveStart }, false, false, { x: right, y: bottomYCurveStart }],\r\n\t\t\t[\r\n\t\t\t\t{ x: right, y: bottomYCurveStart },\r\n\t\t\t\t{ x: right, y: bottomYHandle },\r\n\t\t\t\t{ x: rightXHandle, y: bottom },\r\n\t\t\t\t{ x: rightXCurveStart, y: bottom },\r\n\t\t\t],\r\n\t\t\t[{ x: rightXCurveStart, y: bottom }, false, false, { x: leftXCurveStart, y: bottom }],\r\n\t\t\t[\r\n\t\t\t\t{ x: leftXCurveStart, y: bottom },\r\n\t\t\t\t{ x: leftXHandle, y: bottom },\r\n\t\t\t\t{ x: x, y: bottomYHandle },\r\n\t\t\t\t{ x: x, y: bottomYCurveStart },\r\n\t\t\t],\r\n\t\t\t[{ x: x, y: bottomYCurveStart }, false, false, { x: x, y: topYCurveStart }],\r\n\t\t\t[\r\n\t\t\t\t{ x: x, y: topYCurveStart },\r\n\t\t\t\t{ x: x, y: topYHandle },\r\n\t\t\t\t{ x: leftXHandle, y: y },\r\n\t\t\t\t{ x: leftXCurveStart, y: y },\r\n\t\t\t],\r\n\t\t];\r\n\t} else {\r\n\t\t// do square corners\r\n\t\tbezierPath = [\r\n\t\t\t[upperLeft, false, false, upperRight],\r\n\t\t\t[upperRight, false, false, lowerRight],\r\n\t\t\t[lowerRight, false, false, lowerLeft],\r\n\t\t\t[lowerLeft, false, false, upperLeft],\r\n\t\t];\r\n\t}\r\n\r\n\treturn [bezierPath];\r\n}\r\n", "import { log, roundAndSanitize } from './svg-to-bezier.js';\r\n\r\n/**\r\n * Takes the string value of an element's \"transform\" attribute, and\r\n * parses out each individual transform into an object containing the\r\n * transform's name, and an array of the transform's arguments.\r\n * @param {Object} tag - XMLtoJSON representation of a single SVG Tag\r\n * @returns {Array} - Collection of objects containing individual transform names & arguments\r\n */\r\nexport function getTransformData(tag) {\r\n\t// log(`getTransformData`);\r\n\t// log(tag);\r\n\tif (!tag || !tag?.attributes) return [];\r\n\r\n\t/* \r\n\t\ttransform attribute (toLowerCase is called to identify these)\r\n\t\tmatrix(a,b,c,d,e,f)\t// default (1, 0, 0, 1, 0, 0) identity matrix\r\n\t\ttranslate(x, y) \t\t// default (0, 0)\r\n\t\tscale(x, y) \t\t\t\t// default (0, 0)\r\n\t\trotate(a, x, y) \t\t// default (0, 0, 0)\r\n\t\tskewX(a) \t\t\t\t\t\t// default (0)\r\n\t\tskewY(a) \t\t\t\t\t\t// default (0)\r\n\t*/\r\n\tconst supported = ['matrix', 'translate', 'scale', 'rotate', 'skewx', 'skewy'];\r\n\tlet transforms = [];\r\n\tlet temp;\r\n\tlet validatedArgs;\r\n\tif (tag.attributes?.transform) {\r\n\t\t// log(`Detected transforms`);\r\n\t\ttemp = tag.attributes.transform.replaceAll(',', ' ');\r\n\t\ttemp = temp.replaceAll('  ', ' ');\r\n\t\ttemp = temp.toLowerCase();\r\n\t\ttemp = temp.split(')');\r\n\t\ttemp.forEach((value) => {\r\n\t\t\tlet data = value.split('(');\r\n\t\t\tif (data.length === 2) {\r\n\t\t\t\tdata[0] = data[0].trim();\r\n\t\t\t\tdata[1] = data[1].trim();\r\n\t\t\t\tif (supported.indexOf(data[0]) > -1) {\r\n\t\t\t\t\tvalidatedArgs = data[1].split(' ');\r\n\t\t\t\t\tvalidatedArgs = validatedArgs.map((arg) => Number(arg));\r\n\t\t\t\t\ttransforms.push({\r\n\t\t\t\t\t\tname: data[0],\r\n\t\t\t\t\t\targs: validatedArgs,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/*\r\n\t\ttransform-origin attribute\r\n\t\tignore keyword values\r\n\t\t(x, y, z) // default to 0,0 - ignore z value\r\n\t*/\r\n\tif (tag.attributes['transform-origin']) {\r\n\t\t// log(`Detected transform origin`);\r\n\t\ttemp = tag.attributes['transform-origin'];\r\n\t\ttemp = temp.replaceAll(',', ' ');\r\n\t\ttemp = temp.replaceAll('  ', ' ');\r\n\t\tvalidatedArgs = temp.split(' ');\r\n\t\tvalidatedArgs = validatedArgs.map((arg) => Number(arg));\r\n\t\ttransforms.push({\r\n\t\t\tname: 'origin',\r\n\t\t\targs: validatedArgs,\r\n\t\t});\r\n\t}\r\n\r\n\t// Finish up\r\n\t// log(transforms);\r\n\treturn transforms;\r\n}\r\n\r\n/**\r\n * Applies transforms to data in Bezier Data Format\r\n * @param {Array} bezierPaths - Collection of Bezier Paths to transform\r\n * @param {Array} transformData - Collection of transforms to apply\r\n * @returns {Array} - bezierPaths array\r\n */\r\nexport function applyTransformData(bezierPaths = [], transformData = []) {\r\n\t// log(`\\napplyTransformData`);\r\n\t// log(`\\t P A S S E D\\n`);\r\n\t// log('bezierPaths');\r\n\t// log(JSON.stringify(bezierPaths));\r\n\t// log('transformData');\r\n\t// log(transformData);\r\n\r\n\t// log(`\\t V A L I D A T E D\\n`);\r\n\tconst resultBezierPaths = structuredClone(bezierPaths);\r\n\t// log(`\\t RESULT BEZIER PATHS (start)\\n`);\r\n\t// log(JSON.stringify(resultBezierPaths));\r\n\r\n\t// Transforms get applied from right to left in the\r\n\t// order they were included from the attribute\r\n\tlet orderedTransforms = transformData.reverse();\r\n\tlet originData = [0, 0];\r\n\tfor (let t = 0; t < orderedTransforms.length; t++) {\r\n\t\tif (orderedTransforms[t].name === 'origin') {\r\n\t\t\toriginData = orderedTransforms.splice(t, 1);\r\n\t\t\toriginData = originData[0].args;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t// log(`\\t ORDERED TRANSFORMS\\n`);\r\n\t// log(JSON.stringify(orderedTransforms));\r\n\t// log(`originData: ${originData.toString()}`);\r\n\r\n\t// Start transforming\r\n\torderedTransforms.forEach((oneTransform) => {\r\n\t\tif (transformCurve[oneTransform.name]) {\r\n\t\t\t// log(`\\n\\t${oneTransform.name}`);\r\n\t\t\tconst transformFn = transformCurve[oneTransform.name];\r\n\t\t\tresultBezierPaths.forEach((singlePath, pathIndex) => {\r\n\t\t\t\tsinglePath.forEach((singleCurve, curveIndex) => {\r\n\t\t\t\t\t// log(`\\n~~~ TRANSFORM CURVE ${curveIndex}`);\r\n\t\t\t\t\t// log(`\\t\\tbefore transform:`);\r\n\t\t\t\t\t// logCurve(singleCurve);\r\n\r\n\t\t\t\t\tconst resultCurve = transformFn(singleCurve, oneTransform.args, originData);\r\n\t\t\t\t\tresultBezierPaths[pathIndex][curveIndex] = resultCurve;\r\n\r\n\t\t\t\t\t// log(`\\t\\tafter transform:`);\r\n\t\t\t\t\t// logCurve(resultBezierPaths[pathIndex][curveIndex]);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\r\n\t// log(`\\n\\t AFTER TRANSFORM PATHS\\n`);\r\n\t// log(JSON.stringify(resultBezierPaths));\r\n\treturn resultBezierPaths;\r\n}\r\n\r\n/*\r\n\t\tIndividual transform functions\r\n*/\r\n\r\n// Map transform names to their conversion function\r\nconst transformCurve = {\r\n\tmatrix: matrixTransformCurve,\r\n\ttranslate: translateTransformCurve,\r\n\tscale: scaleTransformCurve,\r\n\trotate: rotateTransformCurve,\r\n\tskewx: skewxTransformCurve,\r\n\tskewy: skewyTransformCurve,\r\n};\r\n\r\nfunction matrixTransformCurve(curve = [], args = [], origin = []) {\r\n\t// log(`:: TRANSFORM CURVE :: matrix`);\r\n\tconst resultCurve = [];\r\n\r\n\t// Fill in default values for identity matrix: [1, 0, 0, 1, 0, 0]\r\n\tconst defaults = [1, 0, 0, 1, 0, 0];\r\n\twhile (args.length < 6) {\r\n\t\targs.push(defaults[args.length]);\r\n\t}\r\n\r\n\tlet originX = origin[0] || 0;\r\n\tlet originY = origin[1] || 0;\r\n\t// log(`origin: ${origin.toString()}`);\r\n\t// log(`\\t\\tmatrix: ${args.toString()}`);\r\n\r\n\tfunction calculateNewPoint(oldPoint) {\r\n\t\tif (oldPoint === false) return false;\r\n\t\tconst newPoint = { x: 0, y: 0 };\r\n\r\n\t\t// Translate to origin\r\n\t\tconst translatedX = oldPoint.x - originX;\r\n\t\tconst translatedY = oldPoint.y - originY;\r\n\r\n\t\t// Apply matrix transformation: new_x = a * x + c * y + e, new_y = b * x + d * y + f\r\n\t\tconst transformedX = args[0] * translatedX + args[2] * translatedY + args[4];\r\n\t\tconst transformedY = args[1] * translatedX + args[3] * translatedY + args[5];\r\n\r\n\t\t// Translate back\r\n\t\tnewPoint.x = roundAndSanitize(transformedX + originX);\r\n\t\tnewPoint.y = roundAndSanitize(transformedY + originY);\r\n\r\n\t\treturn newPoint;\r\n\t}\r\n\r\n\tresultCurve[0] = calculateNewPoint(curve[0]);\r\n\tresultCurve[1] = calculateNewPoint(curve[1]);\r\n\tresultCurve[2] = calculateNewPoint(curve[2]);\r\n\tresultCurve[3] = calculateNewPoint(curve[3]);\r\n\r\n\treturn resultCurve;\r\n}\r\n\r\nfunction translateTransformCurve(curve = [], args = []) {\r\n\t// translate transform does not use transform-origin\r\n\t// log(`:: TRANSFORM CURVE :: translate`);\r\n\tconst resultCurve = [];\r\n\tlet dx = args[0] || 0;\r\n\tlet dy = args[1] || 0;\r\n\t// log(`\\t\\ttranslate: ${dx}, ${dy}`);\r\n\t// log(`\\t\\tcurve[0]: ${curve[0].x}, ${curve[0].y}`);\r\n\r\n\tfunction calculateNewPoint(oldPoint) {\r\n\t\tif (oldPoint === false) return false;\r\n\t\tconst newPoint = { x: 0, y: 0 };\r\n\t\tnewPoint.x = roundAndSanitize(oldPoint.x + dx);\r\n\t\tnewPoint.y = roundAndSanitize(oldPoint.y + dy);\r\n\r\n\t\treturn newPoint;\r\n\t}\r\n\r\n\tresultCurve[0] = calculateNewPoint(curve[0]);\r\n\tresultCurve[1] = calculateNewPoint(curve[1]);\r\n\tresultCurve[2] = calculateNewPoint(curve[2]);\r\n\tresultCurve[3] = calculateNewPoint(curve[3]);\r\n\r\n\treturn resultCurve;\r\n}\r\n\r\nfunction scaleTransformCurve(curve = [], args = [], origin = []) {\r\n\t// log(`:: TRANSFORM CURVE :: scale`);\r\n\tconst scaleX = args[0];\r\n\tlet scaleY = args[1];\r\n\tif (!scaleY) scaleY = scaleX;\r\n\tconst resultCurve = [];\r\n\r\n\tlet originX = origin[0] || 0;\r\n\tlet originY = origin[1] || 0;\r\n\t// log(`origin: ${origin.toString()}`);\r\n\t// log(`\\t\\tscale args: ${args.toString()}`);\r\n\t// log(`\\t\\tscale validated: ${scaleX}, ${scaleY}`);\r\n\r\n\tfunction calculateNewPoint(oldPoint) {\r\n\t\tif (oldPoint === false) return false;\r\n\t\tconst newPoint = { x: 0, y: 0 };\r\n\t\tnewPoint.x = roundAndSanitize((oldPoint.x - originX) * scaleX + originX);\r\n\t\tnewPoint.y = roundAndSanitize((oldPoint.y - originY) * scaleY + originY);\r\n\r\n\t\treturn newPoint;\r\n\t}\r\n\r\n\tresultCurve[0] = calculateNewPoint(curve[0]);\r\n\tresultCurve[1] = calculateNewPoint(curve[1]);\r\n\tresultCurve[2] = calculateNewPoint(curve[2]);\r\n\tresultCurve[3] = calculateNewPoint(curve[3]);\r\n\r\n\treturn resultCurve;\r\n}\r\n\r\nfunction rotateTransformCurve(curve = [], args = [], origin = []) {\r\n\t// log(`:: TRANSFORM CURVE :: rotate`);\r\n\t// log(`origin: ${origin.toString()}`);\r\n\tconst angle = angleToRadians(args[0]);\r\n\tconst about = { x: 0, y: 0 };\r\n\tif (!args[1]) args[1] = 0;\r\n\tif (!args[2]) args[2] = 0;\r\n\r\n\tabout.x = args[1] + origin[0];\r\n\tabout.y = args[2] + origin[1];\r\n\r\n\tconst resultCurve = [];\r\n\t// log(`\\t\\trotate args: ${args.toString()}`);\r\n\t// log(`\\t\\trotate validated: ${angle}`);\r\n\t// log(`\\t\\trotate about: ${about.x}, ${about.y}`);\r\n\r\n\tfunction calculateNewPoint(point) {\r\n\t\tif (!point) return false;\r\n\r\n\t\tconst newPoint = { x: 0, y: 0 };\r\n\t\tnewPoint.x = roundAndSanitize(\r\n\t\t\tMath.cos(angle) * (point.x - about.x) - Math.sin(angle) * (point.y - about.y) + about.x\r\n\t\t);\r\n\t\tnewPoint.y = roundAndSanitize(\r\n\t\t\tMath.sin(angle) * (point.x - about.x) + Math.cos(angle) * (point.y - about.y) + about.y\r\n\t\t);\r\n\r\n\t\t// log(newPoint);\r\n\t\t// log('rotate', 'end');\r\n\t\treturn newPoint;\r\n\t}\r\n\r\n\tresultCurve[0] = calculateNewPoint(curve[0]);\r\n\tresultCurve[1] = calculateNewPoint(curve[1]);\r\n\tresultCurve[2] = calculateNewPoint(curve[2]);\r\n\tresultCurve[3] = calculateNewPoint(curve[3]);\r\n\r\n\treturn resultCurve;\r\n}\r\n\r\nfunction skewxTransformCurve(curve = [], args = [], origin = []) {\r\n\t// log(`:: TRANSFORM CURVE :: skewx`);\r\n\tconst resultCurve = [];\r\n\t// log(`\\t\\tskewx: ${args.toString()}`);\r\n\tconst radians = angleToRadians(args[0]);\r\n\tconst yMultiplier = Math.tan(radians);\r\n\r\n\tlet originX = origin[0] || 0;\r\n\tlet originY = origin[1] || 0;\r\n\t// log(`origin: ${origin.toString()}`);\r\n\r\n\tfunction calculateNewPoint(oldPoint) {\r\n\t\tif (!oldPoint) return false;\r\n\t\tconst oldX = oldPoint.x;\r\n\t\tconst oldY = oldPoint.y;\r\n\t\tconst newPoint = { x: 0, y: 0 };\r\n\r\n\t\tnewPoint.x = roundAndSanitize(\r\n\t\t\toldPoint.x - originX + yMultiplier * (oldPoint.y - originY) + originX\r\n\t\t);\r\n\t\tnewPoint.y = roundAndSanitize(oldY);\r\n\r\n\t\treturn newPoint;\r\n\t}\r\n\r\n\tresultCurve[0] = calculateNewPoint(curve[0]);\r\n\tresultCurve[1] = calculateNewPoint(curve[1]);\r\n\tresultCurve[2] = calculateNewPoint(curve[2]);\r\n\tresultCurve[3] = calculateNewPoint(curve[3]);\r\n\r\n\treturn resultCurve;\r\n}\r\n\r\nfunction skewyTransformCurve(curve = [], args = [], origin = []) {\r\n\t// log(`:: TRANSFORM CURVE :: skewy`);\r\n\tconst resultCurve = [];\r\n\t// log(`\\t\\tskewy: ${args.toString()}`);\r\n\tconst radians = angleToRadians(args[0]);\r\n\tconst xMultiplier = Math.tan(radians);\r\n\r\n\tlet originX = origin[0] || 0;\r\n\tlet originY = origin[1] || 0;\r\n\t// log(`origin: ${origin.toString()}`);\r\n\r\n\tfunction calculateNewPoint(oldPoint) {\r\n\t\tif (!oldPoint) return false;\r\n\t\tconst newPoint = { x: 0, y: 0 };\r\n\r\n\t\tnewPoint.x = roundAndSanitize(oldPoint.x);\r\n\t\tnewPoint.y = roundAndSanitize(\r\n\t\t\toldPoint.y - originY + xMultiplier * (oldPoint.x - originX) + originY\r\n\t\t);\r\n\r\n\t\treturn newPoint;\r\n\t}\r\n\r\n\tresultCurve[0] = calculateNewPoint(curve[0]);\r\n\tresultCurve[1] = calculateNewPoint(curve[1]);\r\n\tresultCurve[2] = calculateNewPoint(curve[2]);\r\n\tresultCurve[3] = calculateNewPoint(curve[3]);\r\n\r\n\treturn resultCurve;\r\n}\r\n\r\n/*\r\n\tHelper functions\r\n*/\r\nfunction angleToRadians(angle) {\r\n\tlet result = (Math.PI / 180) * parseFloat(angle);\r\n\treturn result;\r\n}\r\n\r\nfunction logCurve(curve) {\r\n\tconsole.table({\r\n\t\tx: [curve[0].x, curve[1]?.x, curve[2]?.x, curve[3].x],\r\n\t\ty: [curve[0].y, curve[1]?.y, curve[2]?.y, curve[3].y],\r\n\t});\r\n}\r\n", "/**\n * XML to JSON does exactly what it sounds like.\n * Feed it an XML string, and it converts the data\n * to JSON format.\n * @param {String} inputXML - XML data\n * @return {Object} - Javascript object\n */\nexport function XMLtoJSON(inputXML) {\n\tlet xmlDoc;\n\tlet xmlError;\n\n\tif (typeof window.DOMParser !== 'undefined') {\n\t\txmlDoc = new window.DOMParser().parseFromString(inputXML, 'text/xml');\n\t} else if (\n\t\ttypeof window.ActiveXObject !== 'undefined' &&\n\t\tnew window.ActiveXObject('Microsoft.XMLDOM')\n\t) {\n\t\txmlDoc = new window.ActiveXObject('Microsoft.XMLDOM');\n\t\txmlDoc.async = 'false';\n\t\txmlDoc.loadXML(inputXML);\n\t} else {\n\t\tconsole.warn('No XML document parser found.');\n\t\txmlError = new SyntaxError('No XML document parser found.');\n\t\tthrow xmlError;\n\t}\n\n\tconst error = xmlDoc.getElementsByTagName('parserError');\n\tif (error.length) {\n\t\tconst message = xmlDoc.getElementsByTagName('div')[0].innerHTML;\n\t\txmlError = new SyntaxError(trim(message));\n\t\tthrow xmlError;\n\t}\n\n\tconst result = {\n\t\tname: xmlDoc.documentElement.nodeName,\n\t\tattributes: tag_getAttributes(xmlDoc.documentElement.attributes),\n\t\tcontent: tag_getContent(xmlDoc.documentElement),\n\t};\n\n\treturn result;\n}\n\nfunction tag_getContent(parent) {\n\tconst kids = parent.childNodes;\n\n\tif (kids.length === 0) return trim(parent.nodeValue);\n\n\tconst result = [];\n\tlet tagResult;\n\tlet tagContent;\n\tlet tagAttributes;\n\n\tfor (const node of kids) {\n\t\ttagResult = {};\n\t\tif (node.nodeName === '#comment') continue;\n\n\t\ttagContent = tag_getContent(node);\n\t\ttagAttributes = tag_getAttributes(node.attributes);\n\n\t\tif (node.nodeName === '#text' && JSON.stringify(tagAttributes) === '{}') {\n\t\t\ttagResult = trim(tagContent);\n\t\t} else {\n\t\t\ttagResult.name = node.nodeName;\n\t\t\ttagResult.attributes = tagAttributes;\n\t\t\ttagResult.content = tagContent;\n\t\t}\n\n\t\tif (tagResult !== '') result.push(tagResult);\n\t}\n\n\treturn result;\n}\n\nfunction tag_getAttributes(attributes) {\n\tif (!attributes || !attributes.length) return {};\n\n\tconst result = {};\n\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = trim(attribute.value);\n\t}\n\n\treturn result;\n}\n\nfunction trim(text) {\n\ttry {\n\t\ttext = text.replace(/^\\s+|\\s+$/g, '');\n\t\treturn text.replace(/(\\r\\n|\\n|\\r|\\t)/gm, '');\n\t} catch (e) {\n\t\treturn '';\n\t}\n}\n", "/*\r\n\tSVG to Bezier\r\n\tFor more details, see: https://github.com/mattlag/SVG-to-Bezier\r\n\tAlso, more info on our 'Bezier Data Format' in bezier-data-format.md in this folder\r\n\tVersion: 2.3.0\r\n*/\r\n\r\nimport { tagConvertCircleEllipse } from './tag-convert-circle-ellipse.js';\r\nimport { tagConvertPath } from './tag-convert-path.js';\r\nimport { tagConvertPolygonPolyline } from './tag-convert-polygon-polyline.js';\r\nimport { tagConvertRect } from './tag-convert-rect.js';\r\nimport { applyTransformData, getTransformData } from './transforms.js';\r\nimport { XMLtoJSON } from './xml-to-json.js';\r\n\r\n/**\r\n * Global settings\r\n */\r\nexport const enableConsoleLogging = false;\r\nexport const roundToDecimalPrecision = false;\r\n\r\n/**\r\n * Takes an input SVG document in string format, and converts it to\r\n * a JSON object in Bezier Data Format.\r\n * @param {String} inputSVG - xml svg to convert\r\n * @returns {Array} - collection of Paths in Bezier Data Format\r\n */\r\nexport function SVGtoBezier(inputSVG) {\r\n\t// log(`\\n\\n========================\\n========================\\nSVGtoBezier`);\r\n\t// log(inputSVG);\r\n\tlet svgDocumentData = XMLtoJSON(inputSVG);\r\n\t// log(`JSON DATA`);\r\n\t// log(svgDocumentData);\r\n\tlet bezierPaths = convertTags(svgDocumentData, svgDocumentData);\r\n\t// log(bezierPaths);\r\n\t// log(`SVGtoBezier\\n========================\\n========================\\n\\n`);\r\n\treturn bezierPaths;\r\n}\r\n\r\n/**\r\n * Recursively look through the SVG data and convert individual tags\r\n * @param {Object} tagData - XML to JSON format of a SVG Tag, it's attributes, and content\r\n * @param {Object} svgDocumentData - full SVG document data for xlink lookups\r\n * @returns {Array} - collection of Paths in Bezier Data Format\r\n */\r\nfunction convertTags(tagData, svgDocumentData) {\r\n\t// log(`\\n\\nCONVERT TAGS - START ${tagData.name}`);\r\n\t// log('tagData');\r\n\t// log(tagData);\r\n\tif (!tagData?.content) return [];\r\n\r\n\tlet resultBezierPaths = [];\r\n\r\n\ttagData.content.forEach((tag) => {\r\n\t\t// log(`\\n\\n\\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n START TAG ${tag.name}`);\r\n\t\t// log('tag');\r\n\t\t// log(tag);\r\n\r\n\t\tlet name = tag.name.toLowerCase();\r\n\r\n\t\t// Convert use tags to their referenced element\r\n\t\tif (name === 'use') {\r\n\t\t\tlet id = tag.attributes['href'] || tag.attributes['xlink:href'];\r\n\t\t\tif (id) {\r\n\t\t\t\ttag.name = 'g';\r\n\t\t\t\tname = 'g';\r\n\t\t\t\tif (id.charAt(0) === '#') id = id.substring(1);\r\n\t\t\t\ttag.content = getCopyOfTagByID(id, svgDocumentData);\r\n\t\t\t\tif (!tag.attributes.transform) tag.attributes.transform = '';\r\n\t\t\t\ttag.attributes.transform += `translate(${tag.attributes.x || 0}, ${tag.attributes.y || 0})`;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Collect transforms\r\n\t\tconst tagTransforms = getTransformData(tag);\r\n\t\t// log(`tagTransforms`);\r\n\t\t// log(tagTransforms);\r\n\r\n\t\t// Convert supported tags\r\n\t\tif (convert[name]) {\r\n\t\t\t// log(`\\n\\n======= converting ${tag.name} =======`);\r\n\t\t\tlet bezierPaths;\r\n\t\t\tif (name === 'g') bezierPaths = convertTags(tag, svgDocumentData);\r\n\t\t\telse bezierPaths = convert[name](tag);\r\n\t\t\t// log(`converted tag: \\n${JSON.stringify(bezierPaths)}`);\r\n\t\t\tif (tagTransforms) {\r\n\t\t\t\t// log(`\\n\\n======= transforming ${tag.name} =======`);\r\n\t\t\t\tbezierPaths = applyTransformData(bezierPaths, tagTransforms);\r\n\t\t\t}\r\n\t\t\t// log(`transformed tag: \\n${JSON.stringify(bezierPaths)}`);\r\n\t\t\tresultBezierPaths = resultBezierPaths.concat(bezierPaths);\r\n\t\t}\r\n\r\n\t\t// log(`>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n END TAG ${tag.name}\\n\\n\\n\\n`);\r\n\t});\r\n\r\n\t// log(`resultBezierPaths`);\r\n\t// log(resultBezierPaths);\r\n\t// log(`CONVERT TAGS - END ${tagData.name}\\n\\n`);\r\n\treturn resultBezierPaths;\r\n}\r\n\r\n/**\r\n * Conversion functions for each SVG tag type\r\n */\r\nconst convert = {\r\n\tcircle: tagConvertCircleEllipse,\r\n\tellipse: tagConvertCircleEllipse,\r\n\tpath: tagConvertPath,\r\n\tglyph: tagConvertPath,\r\n\tpolygon: tagConvertPolygonPolyline,\r\n\tpolyline: tagConvertPolygonPolyline,\r\n\trect: tagConvertRect,\r\n\tg: convertTags,\r\n};\r\n\r\n/*\r\n * Common Functions\r\n */\r\n\r\n/**\r\n * Takes a string of number data and makes it easier to work with.\r\n * @param {String} data - data from an XML attribute\r\n * @returns {String} sanitized numbers separated by commas\r\n */\r\nexport function sanitizeParameterData(data) {\r\n\t// Clean up whitespace and replace with commas\r\n\tdata = data.replace(/\\s+/g, ',');\r\n\r\n\t// Clean up numbers\r\n\t//\t\tMaintain scientific notation e+ and e- numbers\r\n\t//\t\tCommas before all negative numbers\r\n\t//\t\tRemove + to denote positive numbers\r\n\tdata = data.replace(/e/gi, 'e');\r\n\r\n\tdata = data.replace(/e-/g, '~~~');\r\n\tdata = data.replace(/-/g, ',-');\r\n\tdata = data.replace(/~~~/g, 'e-');\r\n\r\n\tdata = data.replace(/e\\+/g, '~~~');\r\n\tdata = data.replace(/\\+/g, ',');\r\n\tdata = data.replace(/~~~/g, 'e+');\r\n\r\n\t// Clean up commas\r\n\tdata = data.replace(/,+/g, ',');\r\n\r\n\treturn data;\r\n}\r\n\r\n/**\r\n * Takes a string that came from an XML Attribute, and splits it into an array of numbers.\r\n * It's good to call 'sanitizeParameterData' somewhere before this.\r\n * In addition to chunking, this also checks for \"Decimal number string\" notation.\r\n * @param {String} data - data from an attribute, hopefully numbers separated by commas\r\n * @returns {Array} individual parameters chunked into an array\r\n */\r\nexport function chunkAndValidateParameters(data = '') {\r\n\t// Validate and chunk numeric data\r\n\tlet validatedParameters = [];\r\n\r\n\tif (data.charAt(0) === ',') {\r\n\t\tdata = data.substring(1);\r\n\t}\r\n\r\n\tif (data.charAt(data.length - 1) === ',') {\r\n\t\tdata = data.substring(0, data.length - 1);\r\n\t}\r\n\r\n\tif (data.length > 0) {\r\n\t\tdata = data.split(',');\r\n\r\n\t\t// Handle sequence of decimal numbers without spaces or leading zeros\r\n\t\t// like: 123.45.67.89 should be 123.45, 0.67, 0.89\r\n\t\tdata.forEach((param) => {\r\n\t\t\tparam = param.split('.');\r\n\r\n\t\t\tif (param.length === 1) validatedParameters.push(Number(param[0]));\r\n\t\t\telse if (param.length === 2) validatedParameters.push(Number(param.join('.')));\r\n\t\t\telse if (param.length > 2) {\r\n\t\t\t\tvalidatedParameters.push(Number(`${param[0]}.${param[1]}`));\r\n\t\t\t\tfor (let p = 2; p < param.length; p++) {\r\n\t\t\t\t\tvalidatedParameters.push(Number(`0.${param[p]}`));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// validatedParameters = parameters.map(x => Number(x));\r\n\t}\r\n\r\n\t// log(`chunkAndValidateParameters:\\n${data}\\n${validatedParameters}\\n`);\r\n\treturn validatedParameters;\r\n}\r\n\r\n/**\r\n * Find and duplicate a part of the SVG JSON document based on a given ID\r\n * @param {String} id - what to search for\r\n * @param {Object} rootNode - full SVG document data for xlink lookups\r\n */\r\nexport function getCopyOfTagByID(id, rootNode) {\r\n\t// log(`getCopyOfTagByID`);\r\n\t// log(`id: ${id}`);\r\n\t// log(rootNode);\r\n\r\n\tlet result = [];\r\n\r\n\tif (rootNode.attributes?.id === id) {\r\n\t\tresult = [rootNode];\r\n\t} else if (rootNode.content) {\r\n\t\tfor (let i = 0; i < rootNode.content.length; i++) {\r\n\t\t\tconst childNode = rootNode.content[i];\r\n\t\t\tconst childResult = getCopyOfTagByID(id, childNode);\r\n\t\t\tif (Array.isArray(childResult) && childResult.length > 0) {\r\n\t\t\t\tresult = childResult;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// log(result);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * One call for floating point sanitize and global rounding\r\n * @param {Number} num - number to sanitize\r\n * @returns {Number}\r\n */\r\nexport function roundAndSanitize(num) {\r\n\tnum = floatSanitize(num);\r\n\tnum = round(num, roundToDecimalPrecision);\r\n\treturn num;\r\n}\r\n\r\n/**\r\n * Better rounding than Math.round\r\n * @param {Number} num - number to round\r\n * @param {Number} dec - number of decimal places\r\n * @returns {Number}\r\n */\r\nexport function round(num, dec = false) {\r\n\tif (!num) return 0;\r\n\tif (dec === false) return parseFloat(num);\r\n\tnum = parseFloat(num);\r\n\treturn Number(Math.round(`${num}e${dec}`) + `e-${dec}`) || 0;\r\n}\r\n\r\n/**\r\n * Gets rid of those annoying floating point results that contain\r\n * long sequences of 0s or 9s, and are really close to another\r\n * much more simple number.\r\n * @param {Number} num - number to sanitize\r\n * @returns {Number}\r\n */\r\nexport function floatSanitize(num) {\r\n\tconst stringNum = String(num);\r\n\tif (stringNum.indexOf('00000') > -1 || stringNum.indexOf('99999') > -1) {\r\n\t\tnum = round(num, 5);\r\n\t}\r\n\treturn num;\r\n}\r\n\r\n/**\r\n * Global switch for console logging\r\n * @param {String} message - text to log\r\n */\r\nexport function log(message) {\r\n\tif (enableConsoleLogging) console.log(message);\r\n}\r\n"],
  "mappings": ";;;AAOO,SAAS,wBAAwB,SAAS;AAChD,MAAI,aAAa,CAAC;AAClB,MAAI,QAAO,mCAAS,eAAc,CAAC;AACnC,MAAI,IAAI;AAER,MAAI,KAAK,OAAO,KAAK,EAAE,KAAK;AAC5B,MAAI,KAAK,OAAO,KAAK,EAAE,KAAK;AAE5B,MAAI,QAAQ,SAAS,UAAU;AAC9B,SAAK,IAAI,KAAK,KAAK;AACnB,SAAK,OAAO,KAAK,CAAC,KAAK;AACvB,SAAK;AAAA,EACN,WAAW,QAAQ,SAAS,WAAW;AAEtC,SAAK,OAAO,KAAK,EAAE;AACnB,SAAK,OAAO,KAAK,EAAE;AAEnB,QAAI,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,EAAG,MAAK;AAClC,QAAI,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,EAAG,MAAK;AAElC,QAAI,MAAM,EAAE,EAAG,MAAK;AACpB,QAAI,MAAM,EAAE,EAAG,MAAK;AAAA,EACrB;AAEA,MAAI,eAAe;AAAA,IAClB,MAAM,KAAK;AAAA,IACX,MAAM,KAAK;AAAA,IACX,MAAM,KAAK;AAAA,IACX,MAAM,KAAK;AAAA,EACZ;AAEA,eAAa,kBAAkB,YAAY;AAC3C,SAAO,CAAC,UAAU;AACnB;AAEA,SAAS,kBAAkB,OAAO;AACjC,MAAI,KAAK,MAAM;AACf,MAAI,KAAK,MAAM;AACf,MAAI,KAAK,MAAM;AACf,MAAI,KAAK,MAAM;AAEf,MAAI,MAAM,KAAK,MAAM;AACrB,MAAI,MAAM,KAAK,MAAM;AACrB,MAAI,MAAM,KAAK;AACf,MAAI,MAAM,KAAK;AAWf,MAAI,KAAK,EAAE,GAAG,iBAAiB,KAAK,EAAE,GAAG,GAAG,iBAAiB,EAAE,EAAE;AACjE,MAAI,MAAM,EAAE,GAAG,iBAAiB,KAAK,GAAG,GAAG,GAAG,iBAAiB,EAAE,EAAE;AACnE,MAAI,MAAM,EAAE,GAAG,iBAAiB,KAAK,GAAG,GAAG,GAAG,iBAAiB,EAAE,EAAE;AAGnE,MAAI,KAAK,EAAE,GAAG,iBAAiB,EAAE,GAAG,GAAG,iBAAiB,KAAK,EAAE,EAAE;AACjE,MAAI,MAAM,EAAE,GAAG,iBAAiB,EAAE,GAAG,GAAG,iBAAiB,KAAK,GAAG,EAAE;AACnE,MAAI,MAAM,EAAE,GAAG,iBAAiB,EAAE,GAAG,GAAG,iBAAiB,KAAK,GAAG,EAAE;AAGnE,MAAI,KAAK,EAAE,GAAG,iBAAiB,KAAK,EAAE,GAAG,GAAG,iBAAiB,EAAE,EAAE;AACjE,MAAI,MAAM,EAAE,GAAG,iBAAiB,KAAK,GAAG,GAAG,GAAG,iBAAiB,EAAE,EAAE;AACnE,MAAI,MAAM,EAAE,GAAG,iBAAiB,KAAK,GAAG,GAAG,GAAG,iBAAiB,EAAE,EAAE;AAGnE,MAAI,KAAK,EAAE,GAAG,iBAAiB,EAAE,GAAG,GAAG,iBAAiB,KAAK,EAAE,EAAE;AACjE,MAAI,MAAM,EAAE,GAAG,iBAAiB,EAAE,GAAG,GAAG,iBAAiB,KAAK,GAAG,EAAE;AACnE,MAAI,MAAM,EAAE,GAAG,iBAAiB,EAAE,GAAG,GAAG,iBAAiB,KAAK,GAAG,EAAE;AAEnE,MAAI,QAAQ;AAAA,IACX,CAAC,IAAI,KAAK,KAAK,EAAE;AAAA,IACjB,CAAC,IAAI,KAAK,KAAK,EAAE;AAAA,IACjB,CAAC,IAAI,KAAK,KAAK,EAAE;AAAA,IACjB,CAAC,IAAI,KAAK,KAAK,EAAE;AAAA,EAClB;AAEA,SAAO;AACR;;;ACpEO,SAAS,4BACf,QACA,QACA,SACA,SACA,iBACA,cACA,WACA,MACA,MACA,SACC;AACD,MAAI,aAAa,EAAE,GAAG,QAAQ,GAAG,OAAO;AACxC,MAAI,WAAW,EAAE,GAAG,MAAM,GAAG,KAAK;AAGlC,MAAK,WAAW,QAAQ,WAAW,QAAS,CAAC,WAAW,CAAC,SAAS;AACjE,WAAO,CAAC,WAAW,GAAG,WAAW,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS,CAAC;AAAA,EACnF;AAEA,MAAI,kBAAkB,IAAI,eAAe;AACzC,iBAAe,CAAC,CAAC;AACjB,cAAY,CAAC,CAAC;AAGd,MAAI,SAAS,CAAC;AACd,MAAI;AACJ,MAAI;AAEJ,MAAI,SAAS;AACZ,iBAAa,QAAQ,CAAC;AACtB,eAAW,QAAQ,CAAC;AACpB,aAAS;AAAA,MACR,GAAG,QAAQ,CAAC;AAAA,MACZ,GAAG,QAAQ,CAAC;AAAA,IACb;AAAA,EACD,OAAO;AAEN,iBAAa,OAAO,YAAY,kBAAkB,EAAE;AACpD,eAAW,OAAO,UAAU,kBAAkB,EAAE;AAIhD,QAAI,aAAa,WAAW,IAAI,SAAS,KAAK;AAC9C,QAAI,cAAc,WAAW,IAAI,SAAS,KAAK;AAC/C,QAAI,oBAAoB,aAAa;AACrC,QAAI,mBAAmB,YAAY;AACnC,QAAI,MAAM,oBAAoB,UAAU,WAAW,qBAAqB,UAAU;AAElF,QAAI,MAAM,GAAG;AACZ,YAAM,KAAK,KAAK,GAAG;AACnB,iBAAW;AACX,iBAAW;AAAA,IACZ;AAGA,QAAI,iBAAiB,UAAU;AAC/B,QAAI,iBAAiB,UAAU;AAC/B,QAAI,OAAO,iBAAiB,YAAY,KAAK;AAC7C,YAAQ,KAAK;AAAA,MACZ,KAAK;AAAA,SACH,iBAAiB,iBACjB,iBAAiB,oBACjB,iBAAiB,qBAChB,iBAAiB,oBAAoB,iBAAiB;AAAA,MACzD;AAAA,IACD;AAEA,WAAO,IAAK,OAAO,UAAU,aAAc,WAAW,WAAW,IAAI,SAAS,KAAK;AACnF,WAAO,IAAK,OAAO,KAAK,UAAU,YAAa,WAAW,WAAW,IAAI,SAAS,KAAK;AACvF,iBAAa,KAAK,MAAM,WAAW,IAAI,OAAO,KAAK,OAAO;AAC1D,eAAW,KAAK,MAAM,SAAS,IAAI,OAAO,KAAK,OAAO;AAEtD,iBAAa,WAAW,IAAI,OAAO,IAAI,KAAK,KAAK,aAAa;AAC9D,eAAW,SAAS,IAAI,OAAO,IAAI,KAAK,KAAK,WAAW;AAExD,QAAI,QAAQ,KAAK,KAAK;AACtB,QAAI,aAAa,EAAG,cAAa,QAAQ;AACzC,QAAI,WAAW,EAAG,YAAW,QAAQ;AACrC,QAAI,aAAa,aAAa,SAAU,cAAa,aAAa;AAClE,QAAI,CAAC,aAAa,WAAW,WAAY,YAAW,WAAW;AAAA,EAChE;AAIA,MAAI,aAAa,WAAW;AAC5B,MAAI,SAAS,CAAC;AACd,MAAI,YAAa,KAAK,KAAK,MAAO;AAElC,MAAI,KAAK,IAAI,UAAU,IAAI,WAAW;AACrC,QAAI,cAAc;AAClB,QAAI,eAAe,SAAS;AAC5B,QAAI,eAAe,SAAS;AAC5B,eAAW,aAAa,aAAa,aAAa,WAAW,aAAa,IAAI;AAC9E,aAAS,IAAI,OAAO,IAAI,UAAU,KAAK,IAAI,QAAQ;AACnD,aAAS,IAAI,OAAO,IAAI,UAAU,KAAK,IAAI,QAAQ;AACnD,aAAS;AAAA,MACR,SAAS;AAAA,MACT,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC,UAAU,aAAa,OAAO,GAAG,OAAO,CAAC;AAAA,IAC3C;AAAA,EACD;AAGA,MAAI,eAAe;AAAA,IAClB,GAAG,KAAK,IAAI,UAAU;AAAA,IACtB,GAAG,KAAK,IAAI,UAAU;AAAA,EACvB;AAEA,MAAI,eAAe;AAAA,IAClB,GAAG,KAAK,IAAI,QAAQ;AAAA,IACpB,GAAG,KAAK,IAAI,QAAQ;AAAA,EACrB;AAEA,eAAa,WAAW;AACxB,MAAI,aAAc,KAAK,IAAI,aAAa,CAAC,IAAI,IAAK;AAGlD,MAAI,KAAK,EAAE,GAAG,WAAW,GAAG,GAAG,WAAW,EAAE;AAE5C,MAAI,KAAK;AAAA,IACR,GAAG,WAAW,IAAI,UAAU,aAAa,aAAa;AAAA,IACtD,GAAG,WAAW,IAAI,UAAU,aAAa,aAAa;AAAA,EACvD;AACA,KAAG,IAAI,IAAI,GAAG,IAAI,GAAG;AACrB,KAAG,IAAI,IAAI,GAAG,IAAI,GAAG;AAErB,MAAI,KAAK;AAAA,IACR,GAAG,SAAS,IAAI,UAAU,aAAa,aAAa;AAAA,IACpD,GAAG,SAAS,IAAI,UAAU,aAAa,aAAa;AAAA,EACrD;AAEA,MAAI,KAAK,EAAE,GAAG,SAAS,GAAG,GAAG,SAAS,EAAE;AAExC,WAAS,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,OAAO,MAAM;AAE3D,MAAI,SAAS;AACZ,WAAO;AAAA,EACR,OAAO;AACN,QAAI,cAAc,CAAC;AAGnB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,UAAI,IAAI,GAAG;AACV,oBAAY,CAAC,IAAI,OAAO,EAAE,GAAG,OAAO,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE,GAAG,eAAe,EAAE;AAAA,MAC9E,OAAO;AACN,oBAAY,CAAC,IAAI,OAAO,EAAE,GAAG,OAAO,CAAC,GAAG,GAAG,OAAO,IAAI,CAAC,EAAE,GAAG,eAAe,EAAE;AAAA,MAC9E;AACA,kBAAY,CAAC,IAAI,iBAAiB,YAAY,CAAC,CAAC;AAAA,IACjD;AAEA,WAAO;AAAA,EACR;AACD;AAYA,SAAS,IAAI,KAAK;AACjB,SAAO,OAAO,KAAK,KAAK;AACzB;AASA,SAAS,OAAO,OAAO,UAAU,OAAO;AACvC,MAAI,CAAC,MAAO;AACZ,MAAI,aAAa,EAAG,QAAO;AAE3B,UAAQ,SAAS,CAAC;AAClB,QAAM,IAAI,MAAM,KAAK;AACrB,QAAM,IAAI,MAAM,KAAK;AAErB,QAAM,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAC9B,WAAS,IACR,KAAK,IAAI,QAAQ,KAAK,MAAM,IAAI,MAAM,KAAK,KAAK,IAAI,QAAQ,KAAK,MAAM,IAAI,MAAM,KAAK,MAAM;AAC7F,WAAS,IACR,KAAK,IAAI,QAAQ,KAAK,MAAM,IAAI,MAAM,KAAK,KAAK,IAAI,QAAQ,KAAK,MAAM,IAAI,MAAM,KAAK,MAAM;AAE7F,SAAO;AACR;;;AC9MO,SAAS,eAAe,UAAU,CAAC,GAAG;AAE5C,QAAM,aAAa,QAAQ,WAAW,KAAK;AAI3C,MAAI,WAAW,WAAW,KAAK,WAAW,WAAW,GAAG;AACvD,WAAO,CAAC;AAAA,EACT;AAIA,MAAI,WAAW,cAAc,UAAU;AAQvC,aAAW,kBAAkB,QAAQ;AAKrC,aAAW,qBAAqB,QAAQ;AAKxC,aAAW,cAAc,QAAQ;AAKjC,aAAW,qBAAqB,QAAQ;AAKxC,aAAW,wBAAwB,QAAQ;AAK3C,aAAW,YAAY,QAAQ;AAK/B,QAAM,cAAc,6BAA6B,QAAQ;AAEzD,SAAO;AACR;AAEA,SAAS,6BAA6B,UAAU;AAC/C,MAAI,cAAc,CAAC;AACnB,MAAI,cAAc,CAAC;AACnB,MAAI,WAAW;AACf,MAAI,WAAW;AAKf,WAAS,QAAQ,CAAC,YAAY;AAC7B,UAAM,SAAS,QAAQ,cAAc,CAAC;AACtC,WAAO,QAAQ,CAAC,OAAO,MAAO,OAAO,CAAC,IAAI,iBAAiB,KAAK,CAAE;AAElE,QAAI,QAAQ,SAAS,KAAK;AACzB,iBAAW,OAAO,CAAC;AACnB,iBAAW,OAAO,CAAC;AAAA,IACpB;AACA,QAAI,QAAQ,SAAS,KAAK;AACzB,kBAAY,KAAK;AAAA,QAChB,EAAE,GAAG,UAAU,GAAG,SAAS;AAAA,QAC3B;AAAA,QACA;AAAA,QACA,EAAE,GAAG,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE;AAAA,MAC9B,CAAC;AACD,iBAAW,OAAO,CAAC;AACnB,iBAAW,OAAO,CAAC;AAAA,IACpB;AACA,QAAI,QAAQ,SAAS,KAAK;AACzB,kBAAY,KAAK;AAAA,QAChB,EAAE,GAAG,UAAU,GAAG,SAAS;AAAA,QAC3B,EAAE,GAAG,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE;AAAA,QAC7B,EAAE,GAAG,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE;AAAA,QAC7B,EAAE,GAAG,OAAO,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE;AAAA,MAC9B,CAAC;AACD,iBAAW,OAAO,CAAC;AACnB,iBAAW,OAAO,CAAC;AAAA,IACpB;AACA,QAAI,QAAQ,SAAS,KAAK;AACzB,UAAI,YAAY,CAAC,KAAK,YAAY,CAAC,EAAE,CAAC,GAAG;AACxC,oBAAY,KAAK;AAAA,UAChB,EAAE,GAAG,UAAU,GAAG,SAAS;AAAA,UAC3B;AAAA,UACA;AAAA,UACA,EAAE,GAAG,YAAY,CAAC,EAAE,CAAC,EAAE,GAAG,GAAG,YAAY,CAAC,EAAE,CAAC,EAAE,EAAE;AAAA,QAClD,CAAC;AACD,mBAAW,YAAY,CAAC,EAAE,CAAC,EAAE;AAC7B,mBAAW,YAAY,CAAC,EAAE,CAAC,EAAE;AAAA,MAC9B;AACA,kBAAY,KAAK,WAAW;AAC5B,oBAAc,CAAC;AAAA,IAChB;AAAA,EACD,CAAC;AAGD,MAAI,YAAY,OAAQ,aAAY,KAAK,WAAW;AAEpD,SAAO;AACR;AAMA,SAAS,cAAc,YAAY;AAElC,MAAI,SAAS,CAAC;AACd,MAAI,eAAe;AAEnB,MAAI,OAAO,sBAAsB,UAAU;AAI3C,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,QAAI,UAAU,KAAK,OAAO,CAAC,CAAC,GAAG;AAC9B,qBAAe;AAEf;AAAA,IACD;AAAA,EACD;AAEA,MAAI,iBAAiB,OAAO;AAG3B,WAAO,CAAC,EAAE,MAAM,IAAI,CAAC;AAAA,EACtB;AAGA,WAAS,IAAI,eAAe,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpD,QAAI,UAAU,KAAK,OAAO,CAAC,CAAC,GAAG;AAC9B,aAAO,KAAK;AAAA,QACX,MAAM,KAAK,OAAO,YAAY;AAAA,QAC9B,YAAY,2BAA2B,KAAK,UAAU,eAAe,GAAG,CAAC,CAAC;AAAA,MAC3E,CAAC;AAED,qBAAe;AAAA,IAChB;AAAA,EACD;AAGA,MAAI,eAAe,KAAK,QAAQ;AAC/B,WAAO,KAAK;AAAA,MACX,MAAM,KAAK,OAAO,YAAY;AAAA,MAC9B,YAAY,2BAA2B,KAAK,UAAU,eAAe,GAAG,KAAK,MAAM,CAAC;AAAA,IACrF,CAAC;AAAA,EACF;AAIA,SAAO;AACR;AAEA,SAAS,kBAAkB,UAAU;AAEpC,MAAI,SAAS,CAAC;AACd,MAAI,aAAa,CAAC;AAClB,MAAI,eAAe,EAAE,GAAG,GAAG,GAAG,EAAE;AAChC,MAAI,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAC5B,eAAa,CAAC;AAEd,WAAS,QAAQ,CAAC,YAAY;AAE7B,QAAI,QAAQ,SAAS,OAAO,QAAQ,SAAS,KAAK;AAIjD,mBAAa;AAAA,QACZ,MAAM,QAAQ,SAAS,MAAM,MAAM;AAAA,QACnC,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,qBAAa,IAAI,SAAS;AAC1B,YAAI,QAAQ,SAAS,KAAK;AAEzB,wBAAc,QAAQ;AAAA,QACvB;AAAA,MACD;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,KAAK;AAEhC,mBAAa;AAAA,QACZ,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK;AACnD,iBAAS,IAAI,QAAQ,WAAW,CAAC,IAAI,aAAa;AAClD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,sBAAc,QAAQ;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,KAAK;AAEhC,mBAAa;AAAA,QACZ,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK;AACnD,iBAAS,IAAI,QAAQ,WAAW,CAAC,IAAI,aAAa;AAClD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,sBAAc,QAAQ;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,KAAK;AAEhC,mBAAa;AAAA,QACZ,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,qBAAa,IAAI,SAAS;AAC1B,sBAAc,QAAQ;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,KAAK;AAEhC,mBAAa;AAAA,QACZ,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,qBAAa,IAAI,SAAS;AAC1B,sBAAc,QAAQ;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,KAAK;AAEhC,mBAAa;AAAA,QACZ,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa,CAAC;AACrE,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,qBAAa,IAAI,SAAS;AAC1B,sBAAc,QAAQ;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,KAAK;AAEhC,mBAAa;AAAA,QACZ,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,qBAAa,IAAI,SAAS;AAC1B,sBAAc,QAAQ;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,KAAK;AAEhC,mBAAa;AAAA,QACZ,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACd;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,CAAC;AACpD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,CAAC;AACpD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,CAAC;AACpD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,CAAC;AACpD,mBAAW,WAAW,KAAK,QAAQ,WAAW,IAAI,CAAC,CAAC;AACpD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,iBAAS,IAAI,QAAQ,WAAW,IAAI,CAAC,IAAI,aAAa;AACtD,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,mBAAW,WAAW,KAAK,SAAS,CAAC;AACrC,qBAAa,IAAI,SAAS;AAC1B,qBAAa,IAAI,SAAS;AAC1B,sBAAc,QAAQ;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACvB,WAAW,QAAQ,SAAS,OAAO,QAAQ,SAAS,KAAK;AAExD,qBAAe,EAAE,GAAG,WAAW,GAAG,GAAG,WAAW,EAAE;AAIlD,mBAAa;AACb,aAAO,KAAK,EAAE,MAAM,IAAI,CAAC;AAAA,IAC1B,OAAO;AAEN,UAAI,QAAQ,SAAS,KAAK;AAEzB,qBAAa,IAAI,QAAQ,WAAW,CAAC;AACrC,qBAAa,IAAI,QAAQ,WAAW,CAAC;AAAA,MACtC;AACA,aAAO,KAAK,OAAO;AACnB,oBAAc,YAAY;AAC1B,qBAAe,eAAe,cAAc,OAAO;AAAA,IACpD;AAAA,EACD,CAAC;AAED,SAAO;AACR;AAEA,SAAS,qBAAqB,UAAU;AACvC,MAAI,SAAS,CAAC;AAEd,WAAS,QAAQ,CAAC,YAAY;AAC7B,QAAI,QAAQ,MAAM;AACjB,cAAQ,QAAQ,MAAM;AAAA,QACrB,KAAK;AAAA,QACL,KAAK;AACJ,iBAAO,KAAK,EAAE,MAAM,IAAI,CAAC;AACzB;AAAA,QAED,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACJ,mBAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK;AACnD,mBAAO,KAAK;AAAA,cACX,MAAM,QAAQ;AAAA,cACd,YAAY,CAAC,QAAQ,WAAW,CAAC,CAAC;AAAA,YACnC,CAAC;AAAA,UACF;AACA;AAAA,QAED,KAAK;AAEJ,mBAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAO,KAAK;AAAA,cACX,MAAM,IAAI,IAAI,MAAM;AAAA,cACpB,YAAY,CAAC,QAAQ,WAAW,CAAC,GAAG,QAAQ,WAAW,IAAI,CAAC,CAAC;AAAA,YAC9D,CAAC;AAAA,UACF;AACA;AAAA,QAED,KAAK;AAEJ,mBAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAO,KAAK;AAAA,cACX,MAAM,IAAI,IAAI,MAAM;AAAA,cACpB,YAAY,CAAC,QAAQ,WAAW,CAAC,GAAG,QAAQ,WAAW,IAAI,CAAC,CAAC;AAAA,YAC9D,CAAC;AAAA,UACF;AACA;AAAA,QAED,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACJ,mBAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAO,KAAK;AAAA,cACX,MAAM,QAAQ;AAAA,cACd,YAAY,CAAC,QAAQ,WAAW,CAAC,GAAG,QAAQ,WAAW,IAAI,CAAC,CAAC;AAAA,YAC9D,CAAC;AAAA,UACF;AACA;AAAA,QAED,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACJ,mBAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAO,KAAK;AAAA,cACX,MAAM,QAAQ;AAAA,cACd,YAAY;AAAA,gBACX,QAAQ,WAAW,CAAC;AAAA,gBACpB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,cACzB;AAAA,YACD,CAAC;AAAA,UACF;AACA;AAAA,QAED,KAAK;AAAA,QACL,KAAK;AACJ,mBAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAO,KAAK;AAAA,cACX,MAAM,QAAQ;AAAA,cACd,YAAY;AAAA,gBACX,QAAQ,WAAW,CAAC;AAAA,gBACpB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,cACzB;AAAA,YACD,CAAC;AAAA,UACF;AACA;AAAA,QAED,KAAK;AAAA,QACL,KAAK;AACJ,mBAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,mBAAO,KAAK;AAAA,cACX,MAAM,QAAQ;AAAA,cACd,YAAY;AAAA,gBACX,QAAQ,WAAW,CAAC;AAAA,gBACpB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,gBACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,cACzB;AAAA,YACD,CAAC;AAAA,UACF;AACA;AAAA,MACF;AAAA,IACD;AAAA,EACD,CAAC;AAED,SAAO;AACR;AAEA,SAAS,cAAc,UAAU;AAEhC,MAAI,SAAS,CAAC;AACd,MAAI,eAAe,EAAE,GAAG,GAAG,GAAG,EAAE;AAEhC,WAAS,QAAQ,CAAC,YAAY;AAG7B,QAAI,QAAQ,SAAS,KAAK;AACzB,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK;AACnD,eAAO,KAAK;AAAA,UACX,MAAM;AAAA,UACN,YAAY,CAAC,QAAQ,WAAW,CAAC,GAAG,aAAa,CAAC;AAAA,QACnD,CAAC;AAAA,MACF;AAAA,IACD,WAAW,QAAQ,SAAS,KAAK;AAChC,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK;AACnD,eAAO,KAAK;AAAA,UACX,MAAM;AAAA,UACN,YAAY,CAAC,aAAa,GAAG,QAAQ,WAAW,CAAC,CAAC;AAAA,QACnD,CAAC;AAAA,MACF;AAAA,IACD,OAAO;AACN,aAAO,KAAK,OAAO;AAAA,IACpB;AAGA,mBAAe,eAAe,cAAc,OAAO;AAAA,EAEpD,CAAC;AAED,SAAO;AACR;AAEA,SAAS,qBAAqB,UAAU;AAEvC,MAAI,SAAS,CAAC;AACd,MAAI,eAAe,EAAE,GAAG,GAAG,GAAG,EAAE;AAChC,MAAI,iBAAiB,EAAE,GAAG,GAAG,GAAG,EAAE;AAClC,MAAI,eAAe,EAAE,GAAG,GAAG,GAAG,EAAE;AAChC,MAAI;AAEJ,WAAS,QAAQ,CAAC,YAAY;AAC7B,QAAI,QAAQ,SAAS,OAAO,QAAQ,SAAS,KAAK;AACjD,uBAAiB,OAAO,SAAS,IAAI,OAAO,GAAG,EAAE,IAAI;AAIrD,UAAI,kBAAkB,eAAe,SAAS,KAAK;AAClD,uBAAe,IAAI,eAAe,WAAW,CAAC;AAC9C,uBAAe,IAAI,eAAe,WAAW,CAAC;AAAA,MAC/C,WAAW,kBAAkB,eAAe,SAAS,KAAK;AACzD,uBAAe,IAAI,eAAe,WAAW,CAAC;AAC9C,uBAAe,IAAI,eAAe,WAAW,CAAC;AAAA,MAC/C,OAAO;AACN,uBAAe,IAAI,aAAa;AAChC,uBAAe,IAAI,aAAa;AAAA,MACjC;AAEA,qBAAe;AAAA,QACd,GAAG,aAAa,IAAI,eAAe,IAAI,aAAa;AAAA,QACpD,GAAG,aAAa,IAAI,eAAe,IAAI,aAAa;AAAA,MACrD;AAEA,UAAI,QAAQ,SAAS,KAAK;AACzB,eAAO,KAAK;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACX,aAAa;AAAA,YACb,aAAa;AAAA,YACb,QAAQ,WAAW,CAAC;AAAA,YACpB,QAAQ,WAAW,CAAC;AAAA,YACpB,QAAQ,WAAW,CAAC;AAAA,YACpB,QAAQ,WAAW,CAAC;AAAA,UACrB;AAAA,QACD,CAAC;AAAA,MACF,WAAW,QAAQ,SAAS,KAAK;AAChC,eAAO,KAAK;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACX,aAAa;AAAA,YACb,aAAa;AAAA,YACb,QAAQ,WAAW,CAAC;AAAA,YACpB,QAAQ,WAAW,CAAC;AAAA,UACrB;AAAA,QACD,CAAC;AAAA,MACF;AAAA,IACD,OAAO;AACN,aAAO,KAAK,OAAO;AAAA,IACpB;AAEA,mBAAe,eAAe,cAAc,OAAO;AAAA,EACpD,CAAC;AAED,SAAO;AACR;AAEA,SAAS,wBAAwB,UAAU;AAC1C,MAAI,SAAS,CAAC;AACd,MAAI,eAAe,EAAE,GAAG,GAAG,GAAG,EAAE;AAChC,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,WAAS,QAAQ,CAAC,YAAY;AAC7B,QAAI,QAAQ,SAAS,KAAK;AACzB,YAAM,aAAa;AACnB,YAAM,aAAa;AACnB,YAAM,QAAQ,WAAW,CAAC;AAC1B,YAAM,QAAQ,WAAW,CAAC;AAC1B,YAAM,QAAQ,WAAW,CAAC;AAC1B,YAAM,QAAQ,WAAW,CAAC;AAE1B,YAAM,MAAO,IAAI,KAAM,MAAM;AAC7B,YAAM,MAAO,IAAI,KAAM,MAAM;AAE7B,YAAM,MAAO,IAAI,KAAM,MAAM;AAC7B,YAAM,MAAO,IAAI,KAAM,MAAM;AAE7B,aAAO,KAAK,EAAE,MAAM,KAAK,YAAY,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG,EAAE,CAAC;AAAA,IACtE,OAAO;AACN,aAAO,KAAK,OAAO;AAAA,IACpB;AAEA,mBAAe,eAAe,cAAc,OAAO;AAAA,EACpD,CAAC;AAED,SAAO;AACR;AAEA,SAAS,YAAY,UAAU;AAC9B,MAAI,SAAS,CAAC;AACd,MAAI,mBAAmB,CAAC;AACxB,MAAI,eAAe,EAAE,GAAG,GAAG,GAAG,EAAE;AAEhC,WAAS,QAAQ,CAAC,YAAY;AAC7B,QAAI,QAAQ,SAAS,KAAK;AACzB,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,2BAAmB;AAAA,UAClB,aAAa;AAAA,UACb,aAAa;AAAA,UACb,QAAQ,WAAW,IAAI,CAAC;AAAA,UACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,UACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,UACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,UACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,UACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,UACxB,QAAQ,WAAW,IAAI,CAAC;AAAA,UACxB;AAAA,QACD;AAKA,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK,GAAG;AACpD,iBAAO,KAAK;AAAA,YACX,MAAM;AAAA,YACN,YAAY;AAAA,cACX,iBAAiB,IAAI,CAAC;AAAA,cACtB,iBAAiB,IAAI,CAAC;AAAA,cACtB,iBAAiB,IAAI,CAAC;AAAA,cACtB,iBAAiB,IAAI,CAAC;AAAA,cACtB,iBAAiB,IAAI,CAAC;AAAA,cACtB,iBAAiB,IAAI,CAAC;AAAA,YACvB;AAAA,UACD,CAAC;AAAA,QACF;AAEA,uBAAe;AAAA,UACd,GAAG,iBAAiB,GAAG,EAAE;AAAA,UACzB,GAAG,iBAAiB,GAAG,EAAE;AAAA,QAC1B;AAAA,MACD;AAAA,IACD,OAAO;AACN,aAAO,KAAK,OAAO;AACnB,qBAAe,eAAe,cAAc,OAAO;AAAA,IACpD;AAAA,EACD,CAAC;AAED,SAAO;AACR;AAKA,IAAI,aAAa,CAAC;AAClB,SAAS,cAAc,OAAO;AAC7B,MAAI,CAAC,WAAW,eAAe,GAAG,KAAK,CAAC,WAAW,eAAe,GAAG,GAAG;AAEvE,iBAAa;AAAA,MACZ,GAAG,MAAM;AAAA,MACT,GAAG,MAAM;AAAA,IACV;AAAA,EACD;AACD;AAEA,SAAS,eAAe,cAAc,SAAS;AAC9C,MAAI,cAAc;AAAA,IACjB,GAAG,aAAa,KAAK;AAAA,IACrB,GAAG,aAAa,KAAK;AAAA,EACtB;AAEA,UAAQ,QAAQ,MAAM;AAAA,IACrB,KAAK;AAAA,IACL,KAAK;AACJ;AAAA,IAED,KAAK;AACJ,kBAAY,IAAI,QAAQ,WAAW,GAAG,EAAE;AACxC;AAAA,IAED,KAAK;AACJ,kBAAY,IAAI,QAAQ,WAAW,GAAG,EAAE;AACxC;AAAA,IAED,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACJ,kBAAY,IAAI,QAAQ,WAAW,GAAG,EAAE;AACxC,kBAAY,IAAI,QAAQ,WAAW,GAAG,EAAE;AACxC;AAAA,IAED,KAAK;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK;AACnD,oBAAY,KAAK,QAAQ,WAAW,CAAC;AAAA,MACtC;AACA;AAAA,IAED,KAAK;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK;AACnD,oBAAY,KAAK,QAAQ,WAAW,CAAC;AAAA,MACtC;AACA;AAAA,IAED,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AACzC,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AAAA,MAC1C;AACA;AAAA,IAED,KAAK;AAAA,IACL,KAAK;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AACzC,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AAAA,MAC1C;AACA;AAAA,IAED,KAAK;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AACzC,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AAAA,MAC1C;AACA;AAAA,IAED,KAAK;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,WAAW,QAAQ,KAAK,GAAG;AACtD,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AACzC,oBAAY,KAAK,QAAQ,WAAW,IAAI,CAAC;AAAA,MAC1C;AACA;AAAA,EACF;AAEA,SAAO;AACR;AAEA,SAAS,UAAU,GAAG;AAErB,MAAI,uBAAuB,QAAQ,CAAC,IAAI,GAAI,QAAO;AACnD,SAAO;AACR;;;AClvBO,SAAS,0BAA0B,SAAS;AAZnD;AAiBC,MAAI,aAAa,CAAC;AAClB,MAAI,eAAc,wCAAS,eAAT,mBAAqB;AACvC,gBAAc,sBAAsB,WAAW;AAC/C,MAAI,OAAO,2BAA2B,WAAW;AAKjD,MAAI,SAAS,OAAO,KAAK,CAAC,CAAC,KAAK;AAChC,MAAI,SAAS,OAAO,KAAK,CAAC,CAAC,KAAK;AAChC,MAAI,YAAY,OAAO,KAAK,CAAC,CAAC,KAAK;AACnC,MAAI,YAAY,OAAO,KAAK,CAAC,CAAC,KAAK;AAEnC,MAAI,KAAK,SAAS,GAAG;AACpB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACxC,UAAI,KAAK,OAAO,KAAK,CAAC,CAAC,KAAK;AAC5B,UAAI,KAAK,OAAO,KAAK,IAAI,CAAC,CAAC,KAAK;AAChC,iBAAW,KAAK;AAAA,QACf,EAAE,GAAG,iBAAiB,SAAS,GAAG,GAAG,iBAAiB,SAAS,EAAE;AAAA,QACjE;AAAA,QACA;AAAA,QACA,EAAE,GAAG,iBAAiB,EAAE,GAAG,GAAG,iBAAiB,EAAE,EAAE;AAAA,MACpD,CAAC;AACD,kBAAY;AACZ,kBAAY;AAAA,IACb;AAAA,EACD;AAEA,MAAI,QAAQ,SAAS,aAAa,KAAK,SAAS,GAAG;AAElD,eAAW,KAAK;AAAA,MACf,EAAE,GAAG,iBAAiB,SAAS,GAAG,GAAG,iBAAiB,SAAS,EAAE;AAAA,MACjE;AAAA,MACA;AAAA,MACA,EAAE,GAAG,iBAAiB,MAAM,GAAG,GAAG,iBAAiB,MAAM,EAAE;AAAA,IAC5D,CAAC;AAAA,EACF;AAEA,SAAO,CAAC,UAAU;AACnB;;;ACjDO,SAAS,eAAe,SAAS;AACvC,MAAI,OAAO,QAAQ,cAAc,CAAC;AAClC,MAAI,IAAI,iBAAiB,KAAK,CAAC,KAAK;AACpC,MAAI,IAAI,iBAAiB,KAAK,CAAC,KAAK;AACpC,MAAI,IAAI,iBAAiB,KAAK,KAAK,KAAK;AACxC,MAAI,IAAI,iBAAiB,KAAK,MAAM,KAAK;AACzC,MAAI,QAAQ,IAAI;AAChB,MAAI,SAAS,IAAI;AACjB,MAAI,YAAY,EAAE,GAAM,EAAK;AAC7B,MAAI,aAAa,EAAE,GAAG,OAAO,EAAK;AAClC,MAAI,aAAa,EAAE,GAAG,OAAO,GAAG,OAAO;AACvC,MAAI,YAAY,EAAE,GAAM,GAAG,OAAO;AAClC,MAAI,aAAa,CAAC;AAGlB,MAAI,KAAK,MAAM,KAAK,IAAI;AAEvB,QAAI,KAAK,OAAO,KAAK,EAAE;AACvB,QAAI,KAAK,OAAO,KAAK,EAAE;AAEvB,QAAI,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,EAAG,MAAK;AAClC,QAAI,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,EAAG,MAAK;AAElC,QAAI,MAAM,EAAE,EAAG,MAAK;AACpB,QAAI,MAAM,EAAE,EAAG,MAAK;AAEpB,QAAI,KAAK,IAAI,EAAG,MAAK,IAAI;AACzB,QAAI,KAAK,IAAI,EAAG,MAAK,IAAI;AAGzB,QAAI,cAAc,KAAK;AACvB,QAAI,eAAe,KAAK;AAGxB,QAAI,kBAAkB,iBAAiB,IAAI,EAAE;AAC7C,QAAI,mBAAmB,iBAAiB,QAAQ,EAAE;AAClD,QAAI,iBAAiB,iBAAiB,IAAI,EAAE;AAC5C,QAAI,oBAAoB,iBAAiB,SAAS,EAAE;AAGpD,QAAI,cAAc,iBAAiB,IAAI,WAAW;AAClD,QAAI,eAAe,iBAAiB,QAAQ,WAAW;AACvD,QAAI,aAAa,iBAAiB,IAAI,YAAY;AAClD,QAAI,gBAAgB,iBAAiB,SAAS,YAAY;AAE1D,iBAAa;AAAA,MACZ,CAAC,EAAE,GAAG,iBAAiB,EAAK,GAAG,OAAO,OAAO,EAAE,GAAG,kBAAkB,EAAK,CAAC;AAAA,MAC1E;AAAA,QACC,EAAE,GAAG,kBAAkB,EAAK;AAAA,QAC5B,EAAE,GAAG,cAAc,EAAK;AAAA,QACxB,EAAE,GAAG,OAAO,GAAG,WAAW;AAAA,QAC1B,EAAE,GAAG,OAAO,GAAG,eAAe;AAAA,MAC/B;AAAA,MACA,CAAC,EAAE,GAAG,OAAO,GAAG,eAAe,GAAG,OAAO,OAAO,EAAE,GAAG,OAAO,GAAG,kBAAkB,CAAC;AAAA,MAClF;AAAA,QACC,EAAE,GAAG,OAAO,GAAG,kBAAkB;AAAA,QACjC,EAAE,GAAG,OAAO,GAAG,cAAc;AAAA,QAC7B,EAAE,GAAG,cAAc,GAAG,OAAO;AAAA,QAC7B,EAAE,GAAG,kBAAkB,GAAG,OAAO;AAAA,MAClC;AAAA,MACA,CAAC,EAAE,GAAG,kBAAkB,GAAG,OAAO,GAAG,OAAO,OAAO,EAAE,GAAG,iBAAiB,GAAG,OAAO,CAAC;AAAA,MACpF;AAAA,QACC,EAAE,GAAG,iBAAiB,GAAG,OAAO;AAAA,QAChC,EAAE,GAAG,aAAa,GAAG,OAAO;AAAA,QAC5B,EAAE,GAAM,GAAG,cAAc;AAAA,QACzB,EAAE,GAAM,GAAG,kBAAkB;AAAA,MAC9B;AAAA,MACA,CAAC,EAAE,GAAM,GAAG,kBAAkB,GAAG,OAAO,OAAO,EAAE,GAAM,GAAG,eAAe,CAAC;AAAA,MAC1E;AAAA,QACC,EAAE,GAAM,GAAG,eAAe;AAAA,QAC1B,EAAE,GAAM,GAAG,WAAW;AAAA,QACtB,EAAE,GAAG,aAAa,EAAK;AAAA,QACvB,EAAE,GAAG,iBAAiB,EAAK;AAAA,MAC5B;AAAA,IACD;AAAA,EACD,OAAO;AAEN,iBAAa;AAAA,MACZ,CAAC,WAAW,OAAO,OAAO,UAAU;AAAA,MACpC,CAAC,YAAY,OAAO,OAAO,UAAU;AAAA,MACrC,CAAC,YAAY,OAAO,OAAO,SAAS;AAAA,MACpC,CAAC,WAAW,OAAO,OAAO,SAAS;AAAA,IACpC;AAAA,EACD;AAEA,SAAO,CAAC,UAAU;AACnB;;;ACpFO,SAAS,iBAAiB,KAAK;AATtC;AAYC,MAAI,CAAC,OAAO,EAAC,2BAAK,YAAY,QAAO,CAAC;AAWtC,QAAM,YAAY,CAAC,UAAU,aAAa,SAAS,UAAU,SAAS,OAAO;AAC7E,MAAI,aAAa,CAAC;AAClB,MAAI;AACJ,MAAI;AACJ,OAAI,SAAI,eAAJ,mBAAgB,WAAW;AAE9B,WAAO,IAAI,WAAW,UAAU,WAAW,KAAK,GAAG;AACnD,WAAO,KAAK,WAAW,MAAM,GAAG;AAChC,WAAO,KAAK,YAAY;AACxB,WAAO,KAAK,MAAM,GAAG;AACrB,SAAK,QAAQ,CAAC,UAAU;AACvB,UAAI,OAAO,MAAM,MAAM,GAAG;AAC1B,UAAI,KAAK,WAAW,GAAG;AACtB,aAAK,CAAC,IAAI,KAAK,CAAC,EAAE,KAAK;AACvB,aAAK,CAAC,IAAI,KAAK,CAAC,EAAE,KAAK;AACvB,YAAI,UAAU,QAAQ,KAAK,CAAC,CAAC,IAAI,IAAI;AACpC,0BAAgB,KAAK,CAAC,EAAE,MAAM,GAAG;AACjC,0BAAgB,cAAc,IAAI,CAAC,QAAQ,OAAO,GAAG,CAAC;AACtD,qBAAW,KAAK;AAAA,YACf,MAAM,KAAK,CAAC;AAAA,YACZ,MAAM;AAAA,UACP,CAAC;AAAA,QACF;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AAOA,MAAI,IAAI,WAAW,kBAAkB,GAAG;AAEvC,WAAO,IAAI,WAAW,kBAAkB;AACxC,WAAO,KAAK,WAAW,KAAK,GAAG;AAC/B,WAAO,KAAK,WAAW,MAAM,GAAG;AAChC,oBAAgB,KAAK,MAAM,GAAG;AAC9B,oBAAgB,cAAc,IAAI,CAAC,QAAQ,OAAO,GAAG,CAAC;AACtD,eAAW,KAAK;AAAA,MACf,MAAM;AAAA,MACN,MAAM;AAAA,IACP,CAAC;AAAA,EACF;AAIA,SAAO;AACR;AAQO,SAAS,mBAAmB,cAAc,CAAC,GAAG,gBAAgB,CAAC,GAAG;AASxE,QAAM,oBAAoB,gBAAgB,WAAW;AAMrD,MAAI,oBAAoB,cAAc,QAAQ;AAC9C,MAAI,aAAa,CAAC,GAAG,CAAC;AACtB,WAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,KAAK;AAClD,QAAI,kBAAkB,CAAC,EAAE,SAAS,UAAU;AAC3C,mBAAa,kBAAkB,OAAO,GAAG,CAAC;AAC1C,mBAAa,WAAW,CAAC,EAAE;AAC3B;AAAA,IACD;AAAA,EACD;AAMA,oBAAkB,QAAQ,CAAC,iBAAiB;AAC3C,QAAI,eAAe,aAAa,IAAI,GAAG;AAEtC,YAAM,cAAc,eAAe,aAAa,IAAI;AACpD,wBAAkB,QAAQ,CAAC,YAAY,cAAc;AACpD,mBAAW,QAAQ,CAAC,aAAa,eAAe;AAK/C,gBAAM,cAAc,YAAY,aAAa,aAAa,MAAM,UAAU;AAC1E,4BAAkB,SAAS,EAAE,UAAU,IAAI;AAAA,QAI5C,CAAC;AAAA,MACF,CAAC;AAAA,IACF;AAAA,EACD,CAAC;AAID,SAAO;AACR;AAOA,IAAM,iBAAiB;AAAA,EACtB,QAAQ;AAAA,EACR,WAAW;AAAA,EACX,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AACR;AAEA,SAAS,qBAAqB,QAAQ,CAAC,GAAG,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG;AAEjE,QAAM,cAAc,CAAC;AAGrB,QAAM,WAAW,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAClC,SAAO,KAAK,SAAS,GAAG;AACvB,SAAK,KAAK,SAAS,KAAK,MAAM,CAAC;AAAA,EAChC;AAEA,MAAI,UAAU,OAAO,CAAC,KAAK;AAC3B,MAAI,UAAU,OAAO,CAAC,KAAK;AAI3B,WAAS,kBAAkB,UAAU;AACpC,QAAI,aAAa,MAAO,QAAO;AAC/B,UAAM,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAG9B,UAAM,cAAc,SAAS,IAAI;AACjC,UAAM,cAAc,SAAS,IAAI;AAGjC,UAAM,eAAe,KAAK,CAAC,IAAI,cAAc,KAAK,CAAC,IAAI,cAAc,KAAK,CAAC;AAC3E,UAAM,eAAe,KAAK,CAAC,IAAI,cAAc,KAAK,CAAC,IAAI,cAAc,KAAK,CAAC;AAG3E,aAAS,IAAI,iBAAiB,eAAe,OAAO;AACpD,aAAS,IAAI,iBAAiB,eAAe,OAAO;AAEpD,WAAO;AAAA,EACR;AAEA,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAE3C,SAAO;AACR;AAEA,SAAS,wBAAwB,QAAQ,CAAC,GAAG,OAAO,CAAC,GAAG;AAGvD,QAAM,cAAc,CAAC;AACrB,MAAI,KAAK,KAAK,CAAC,KAAK;AACpB,MAAI,KAAK,KAAK,CAAC,KAAK;AAIpB,WAAS,kBAAkB,UAAU;AACpC,QAAI,aAAa,MAAO,QAAO;AAC/B,UAAM,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAC9B,aAAS,IAAI,iBAAiB,SAAS,IAAI,EAAE;AAC7C,aAAS,IAAI,iBAAiB,SAAS,IAAI,EAAE;AAE7C,WAAO;AAAA,EACR;AAEA,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAE3C,SAAO;AACR;AAEA,SAAS,oBAAoB,QAAQ,CAAC,GAAG,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG;AAEhE,QAAM,SAAS,KAAK,CAAC;AACrB,MAAI,SAAS,KAAK,CAAC;AACnB,MAAI,CAAC,OAAQ,UAAS;AACtB,QAAM,cAAc,CAAC;AAErB,MAAI,UAAU,OAAO,CAAC,KAAK;AAC3B,MAAI,UAAU,OAAO,CAAC,KAAK;AAK3B,WAAS,kBAAkB,UAAU;AACpC,QAAI,aAAa,MAAO,QAAO;AAC/B,UAAM,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAC9B,aAAS,IAAI,kBAAkB,SAAS,IAAI,WAAW,SAAS,OAAO;AACvE,aAAS,IAAI,kBAAkB,SAAS,IAAI,WAAW,SAAS,OAAO;AAEvE,WAAO;AAAA,EACR;AAEA,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAE3C,SAAO;AACR;AAEA,SAAS,qBAAqB,QAAQ,CAAC,GAAG,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG;AAGjE,QAAM,QAAQ,eAAe,KAAK,CAAC,CAAC;AACpC,QAAM,QAAQ,EAAE,GAAG,GAAG,GAAG,EAAE;AAC3B,MAAI,CAAC,KAAK,CAAC,EAAG,MAAK,CAAC,IAAI;AACxB,MAAI,CAAC,KAAK,CAAC,EAAG,MAAK,CAAC,IAAI;AAExB,QAAM,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC;AAC5B,QAAM,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC;AAE5B,QAAM,cAAc,CAAC;AAKrB,WAAS,kBAAkB,OAAO;AACjC,QAAI,CAAC,MAAO,QAAO;AAEnB,UAAM,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAC9B,aAAS,IAAI;AAAA,MACZ,KAAK,IAAI,KAAK,KAAK,MAAM,IAAI,MAAM,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,IAAI,MAAM,KAAK,MAAM;AAAA,IACvF;AACA,aAAS,IAAI;AAAA,MACZ,KAAK,IAAI,KAAK,KAAK,MAAM,IAAI,MAAM,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,IAAI,MAAM,KAAK,MAAM;AAAA,IACvF;AAIA,WAAO;AAAA,EACR;AAEA,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAE3C,SAAO;AACR;AAEA,SAAS,oBAAoB,QAAQ,CAAC,GAAG,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG;AAEhE,QAAM,cAAc,CAAC;AAErB,QAAM,UAAU,eAAe,KAAK,CAAC,CAAC;AACtC,QAAM,cAAc,KAAK,IAAI,OAAO;AAEpC,MAAI,UAAU,OAAO,CAAC,KAAK;AAC3B,MAAI,UAAU,OAAO,CAAC,KAAK;AAG3B,WAAS,kBAAkB,UAAU;AACpC,QAAI,CAAC,SAAU,QAAO;AACtB,UAAM,OAAO,SAAS;AACtB,UAAM,OAAO,SAAS;AACtB,UAAM,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAE9B,aAAS,IAAI;AAAA,MACZ,SAAS,IAAI,UAAU,eAAe,SAAS,IAAI,WAAW;AAAA,IAC/D;AACA,aAAS,IAAI,iBAAiB,IAAI;AAElC,WAAO;AAAA,EACR;AAEA,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAE3C,SAAO;AACR;AAEA,SAAS,oBAAoB,QAAQ,CAAC,GAAG,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG;AAEhE,QAAM,cAAc,CAAC;AAErB,QAAM,UAAU,eAAe,KAAK,CAAC,CAAC;AACtC,QAAM,cAAc,KAAK,IAAI,OAAO;AAEpC,MAAI,UAAU,OAAO,CAAC,KAAK;AAC3B,MAAI,UAAU,OAAO,CAAC,KAAK;AAG3B,WAAS,kBAAkB,UAAU;AACpC,QAAI,CAAC,SAAU,QAAO;AACtB,UAAM,WAAW,EAAE,GAAG,GAAG,GAAG,EAAE;AAE9B,aAAS,IAAI,iBAAiB,SAAS,CAAC;AACxC,aAAS,IAAI;AAAA,MACZ,SAAS,IAAI,UAAU,eAAe,SAAS,IAAI,WAAW;AAAA,IAC/D;AAEA,WAAO;AAAA,EACR;AAEA,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAC3C,cAAY,CAAC,IAAI,kBAAkB,MAAM,CAAC,CAAC;AAE3C,SAAO;AACR;AAKA,SAAS,eAAe,OAAO;AAC9B,MAAI,SAAU,KAAK,KAAK,MAAO,WAAW,KAAK;AAC/C,SAAO;AACR;;;AC5VO,SAAS,UAAU,UAAU;AACnC,MAAI;AACJ,MAAI;AAEJ,MAAI,OAAO,OAAO,cAAc,aAAa;AAC5C,aAAS,IAAI,OAAO,UAAU,EAAE,gBAAgB,UAAU,UAAU;AAAA,EACrE,WACC,OAAO,OAAO,kBAAkB,eAChC,IAAI,OAAO,cAAc,kBAAkB,GAC1C;AACD,aAAS,IAAI,OAAO,cAAc,kBAAkB;AACpD,WAAO,QAAQ;AACf,WAAO,QAAQ,QAAQ;AAAA,EACxB,OAAO;AACN,YAAQ,KAAK,+BAA+B;AAC5C,eAAW,IAAI,YAAY,+BAA+B;AAC1D,UAAM;AAAA,EACP;AAEA,QAAM,QAAQ,OAAO,qBAAqB,aAAa;AACvD,MAAI,MAAM,QAAQ;AACjB,UAAM,UAAU,OAAO,qBAAqB,KAAK,EAAE,CAAC,EAAE;AACtD,eAAW,IAAI,YAAY,KAAK,OAAO,CAAC;AACxC,UAAM;AAAA,EACP;AAEA,QAAM,SAAS;AAAA,IACd,MAAM,OAAO,gBAAgB;AAAA,IAC7B,YAAY,kBAAkB,OAAO,gBAAgB,UAAU;AAAA,IAC/D,SAAS,eAAe,OAAO,eAAe;AAAA,EAC/C;AAEA,SAAO;AACR;AAEA,SAAS,eAAe,QAAQ;AAC/B,QAAM,OAAO,OAAO;AAEpB,MAAI,KAAK,WAAW,EAAG,QAAO,KAAK,OAAO,SAAS;AAEnD,QAAM,SAAS,CAAC;AAChB,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,aAAW,QAAQ,MAAM;AACxB,gBAAY,CAAC;AACb,QAAI,KAAK,aAAa,WAAY;AAElC,iBAAa,eAAe,IAAI;AAChC,oBAAgB,kBAAkB,KAAK,UAAU;AAEjD,QAAI,KAAK,aAAa,WAAW,KAAK,UAAU,aAAa,MAAM,MAAM;AACxE,kBAAY,KAAK,UAAU;AAAA,IAC5B,OAAO;AACN,gBAAU,OAAO,KAAK;AACtB,gBAAU,aAAa;AACvB,gBAAU,UAAU;AAAA,IACrB;AAEA,QAAI,cAAc,GAAI,QAAO,KAAK,SAAS;AAAA,EAC5C;AAEA,SAAO;AACR;AAEA,SAAS,kBAAkB,YAAY;AACtC,MAAI,CAAC,cAAc,CAAC,WAAW,OAAQ,QAAO,CAAC;AAE/C,QAAM,SAAS,CAAC;AAEhB,aAAW,aAAa,YAAY;AACnC,WAAO,UAAU,IAAI,IAAI,KAAK,UAAU,KAAK;AAAA,EAC9C;AAEA,SAAO;AACR;AAEA,SAAS,KAAK,MAAM;AACnB,MAAI;AACH,WAAO,KAAK,QAAQ,cAAc,EAAE;AACpC,WAAO,KAAK,QAAQ,qBAAqB,EAAE;AAAA,EAC5C,SAAS,GAAG;AACX,WAAO;AAAA,EACR;AACD;;;AC3EO,IAAM,uBAAuB;AAC7B,IAAM,0BAA0B;AAQhC,SAAS,YAAY,UAAU;AAGrC,MAAI,kBAAkB,UAAU,QAAQ;AAGxC,MAAI,cAAc,YAAY,iBAAiB,eAAe;AAG9D,SAAO;AACR;AAQA,SAAS,YAAY,SAAS,iBAAiB;AAI9C,MAAI,EAAC,mCAAS,SAAS,QAAO,CAAC;AAE/B,MAAI,oBAAoB,CAAC;AAEzB,UAAQ,QAAQ,QAAQ,CAAC,QAAQ;AAKhC,QAAI,OAAO,IAAI,KAAK,YAAY;AAGhC,QAAI,SAAS,OAAO;AACnB,UAAI,KAAK,IAAI,WAAW,MAAM,KAAK,IAAI,WAAW,YAAY;AAC9D,UAAI,IAAI;AACP,YAAI,OAAO;AACX,eAAO;AACP,YAAI,GAAG,OAAO,CAAC,MAAM,IAAK,MAAK,GAAG,UAAU,CAAC;AAC7C,YAAI,UAAU,iBAAiB,IAAI,eAAe;AAClD,YAAI,CAAC,IAAI,WAAW,UAAW,KAAI,WAAW,YAAY;AAC1D,YAAI,WAAW,aAAa,aAAa,IAAI,WAAW,KAAK,CAAC,KAAK,IAAI,WAAW,KAAK,CAAC;AAAA,MACzF;AAAA,IACD;AAGA,UAAM,gBAAgB,iBAAiB,GAAG;AAK1C,QAAI,QAAQ,IAAI,GAAG;AAElB,UAAI;AACJ,UAAI,SAAS,IAAK,eAAc,YAAY,KAAK,eAAe;AAAA,UAC3D,eAAc,QAAQ,IAAI,EAAE,GAAG;AAEpC,UAAI,eAAe;AAElB,sBAAc,mBAAmB,aAAa,aAAa;AAAA,MAC5D;AAEA,0BAAoB,kBAAkB,OAAO,WAAW;AAAA,IACzD;AAAA,EAGD,CAAC;AAKD,SAAO;AACR;AAKA,IAAM,UAAU;AAAA,EACf,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,MAAM;AAAA,EACN,OAAO;AAAA,EACP,SAAS;AAAA,EACT,UAAU;AAAA,EACV,MAAM;AAAA,EACN,GAAG;AACJ;AAWO,SAAS,sBAAsB,MAAM;AAE3C,SAAO,KAAK,QAAQ,QAAQ,GAAG;AAM/B,SAAO,KAAK,QAAQ,OAAO,GAAG;AAE9B,SAAO,KAAK,QAAQ,OAAO,KAAK;AAChC,SAAO,KAAK,QAAQ,MAAM,IAAI;AAC9B,SAAO,KAAK,QAAQ,QAAQ,IAAI;AAEhC,SAAO,KAAK,QAAQ,QAAQ,KAAK;AACjC,SAAO,KAAK,QAAQ,OAAO,GAAG;AAC9B,SAAO,KAAK,QAAQ,QAAQ,IAAI;AAGhC,SAAO,KAAK,QAAQ,OAAO,GAAG;AAE9B,SAAO;AACR;AASO,SAAS,2BAA2B,OAAO,IAAI;AAErD,MAAI,sBAAsB,CAAC;AAE3B,MAAI,KAAK,OAAO,CAAC,MAAM,KAAK;AAC3B,WAAO,KAAK,UAAU,CAAC;AAAA,EACxB;AAEA,MAAI,KAAK,OAAO,KAAK,SAAS,CAAC,MAAM,KAAK;AACzC,WAAO,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC;AAAA,EACzC;AAEA,MAAI,KAAK,SAAS,GAAG;AACpB,WAAO,KAAK,MAAM,GAAG;AAIrB,SAAK,QAAQ,CAAC,UAAU;AACvB,cAAQ,MAAM,MAAM,GAAG;AAEvB,UAAI,MAAM,WAAW,EAAG,qBAAoB,KAAK,OAAO,MAAM,CAAC,CAAC,CAAC;AAAA,eACxD,MAAM,WAAW,EAAG,qBAAoB,KAAK,OAAO,MAAM,KAAK,GAAG,CAAC,CAAC;AAAA,eACpE,MAAM,SAAS,GAAG;AAC1B,4BAAoB,KAAK,OAAO,GAAG,MAAM,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,EAAE,CAAC;AAC1D,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,8BAAoB,KAAK,OAAO,KAAK,MAAM,CAAC,CAAC,EAAE,CAAC;AAAA,QACjD;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EAGF;AAGA,SAAO;AACR;AAOO,SAAS,iBAAiB,IAAI,UAAU;AArM/C;AA0MC,MAAI,SAAS,CAAC;AAEd,QAAI,cAAS,eAAT,mBAAqB,QAAO,IAAI;AACnC,aAAS,CAAC,QAAQ;AAAA,EACnB,WAAW,SAAS,SAAS;AAC5B,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,QAAQ,KAAK;AACjD,YAAM,YAAY,SAAS,QAAQ,CAAC;AACpC,YAAM,cAAc,iBAAiB,IAAI,SAAS;AAClD,UAAI,MAAM,QAAQ,WAAW,KAAK,YAAY,SAAS,GAAG;AACzD,iBAAS;AACT;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAGA,SAAO;AACR;AAOO,SAAS,iBAAiB,KAAK;AACrC,QAAM,cAAc,GAAG;AACvB,QAAM,MAAM,KAAK,uBAAuB;AACxC,SAAO;AACR;AAQO,SAAS,MAAM,KAAK,MAAM,OAAO;AACvC,MAAI,CAAC,IAAK,QAAO;AACjB,MAAI,QAAQ,MAAO,QAAO,WAAW,GAAG;AACxC,QAAM,WAAW,GAAG;AACpB,SAAO,OAAO,KAAK,MAAM,GAAG,GAAG,IAAI,GAAG,EAAE,IAAI,KAAK,GAAG,EAAE,KAAK;AAC5D;AASO,SAAS,cAAc,KAAK;AAClC,QAAM,YAAY,OAAO,GAAG;AAC5B,MAAI,UAAU,QAAQ,OAAO,IAAI,MAAM,UAAU,QAAQ,OAAO,IAAI,IAAI;AACvE,UAAM,MAAM,KAAK,CAAC;AAAA,EACnB;AACA,SAAO;AACR;AAMO,SAAS,IAAI,SAAS;AAC5B,MAAI,qBAAsB,SAAQ,IAAI,OAAO;AAC9C;",
  "names": []
}
